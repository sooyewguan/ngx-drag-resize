{"ast":null,"code":"import _defineProperty from \"/Users/sooyewguan/Desktop/ngx-drag-resize/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Injectable, Inject, EventEmitter, PLATFORM_ID, Input, Output, Optional, HostBinding, NgModule } from '@angular/core';\nimport { merge, fromEvent, EMPTY, Subject } from 'rxjs';\nimport { tap, map, switchMap, takeUntil, filter } from 'rxjs/operators';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\n\n/**\n * The directive is used to work with boundary area for HTML element\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet BoundaryDirective = /*#__PURE__*/(() => {\n  class BoundaryDirective {\n    constructor(windowObject, documentObject) {\n      _defineProperty(this, \"windowObject\", void 0);\n      _defineProperty(this, \"documentObject\", void 0);\n      /**\n       * CSS selector or HTML element\n       */\n      _defineProperty(this, \"boundary\", null);\n      this.windowObject = windowObject;\n      this.documentObject = documentObject;\n    }\n    /**\n     * Get boundary position based on {@link boundary}\n     */\n    getBoundary() {\n      const rect = {};\n      const boundaryElement = this.resolveBoundaryElement();\n      if (boundaryElement instanceof Element) {\n        const boundaryElementRect = boundaryElement.getBoundingClientRect();\n        rect.left = boundaryElementRect.left;\n        rect.top = boundaryElementRect.top;\n        rect.bottom = boundaryElementRect.bottom;\n        rect.right = boundaryElementRect.right;\n        return rect;\n      }\n      if (boundaryElement instanceof Window && this.windowObject) {\n        rect.top = 0;\n        rect.left = 0;\n        rect.right = this.windowObject.innerWidth;\n        rect.bottom = this.windowObject.innerHeight;\n        return rect;\n      }\n      return null;\n    }\n    /**\n     * Resolves HTML element based on {@link boundary}\n     */\n    resolveBoundaryElement() {\n      if (!this.boundary) {\n        return null;\n      }\n      if (this.boundary === 'window' && this.windowObject) {\n        return this.windowObject;\n      }\n      if (typeof this.boundary === 'string') {\n        return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\n      }\n      return this.boundary;\n    }\n    /**\n     * Returns positional value based on boundary position\n     */\n    basedOnBoundary(value, position) {\n      const boundary = this.getBoundary();\n      if (!boundary) {\n        return value;\n      }\n      switch (position) {\n        case 'left':\n          return value - boundary.left;\n        case 'top':\n          return value - boundary.top;\n      }\n      return value;\n    }\n  }\n  _defineProperty(BoundaryDirective, \"\\u0275fac\", function BoundaryDirective_Factory(t) {\n    return new (t || BoundaryDirective)(i0.ɵɵdirectiveInject(Window), i0.ɵɵdirectiveInject(Document));\n  });\n  _defineProperty(BoundaryDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: BoundaryDirective,\n    selectors: [[\"\", \"ngxBoundary\", \"\"]]\n  }));\n  return BoundaryDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A DI Token representing the window object.\n *\n * Note: might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\n *\n * @internal\n */\nconst WINDOW = new InjectionToken('lib.window', {\n  factory: () => typeof window !== 'undefined' ? window : null\n});\n\n/**\n * The service that allows to observe the element dragging\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet DragService = /*#__PURE__*/(() => {\n  class DragService {\n    constructor(document, window) {\n      _defineProperty(this, \"document\", void 0);\n      _defineProperty(this, \"window\", void 0);\n      /**\n       * Emits on mouse or touch event was ended\n       */\n      _defineProperty(this, \"leave$\", merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend')));\n      /**\n       * Emits on mouse or touch move\n       */\n      _defineProperty(this, \"move$\", merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove')));\n      this.document = document;\n      this.window = window;\n    }\n    /**\n     * Creates an observable that emits drag event\n     */\n    fromElement(target) {\n      if (!this.document) {\n        return EMPTY;\n      }\n      const enter$ = merge(fromEvent(target, 'mousedown'), fromEvent(target, 'touchstart'));\n      return enter$.pipe(tap(event => event.preventDefault()), map(event => this.fromEnter(event)), switchMap(event => this.forMove(event)));\n    }\n    /**\n     * Returns position of mouse or touch event\n     */\n    fromMovementNativeEvent(event) {\n      let x = 0;\n      let y = 0;\n      if (!this.window) {\n        return {\n          x,\n          y\n        };\n      }\n      if ('TouchEvent' in this.window && event instanceof TouchEvent) {\n        const touch = event.touches.length ? event.touches.item(0) : null;\n        x = touch ? touch.clientX : 0;\n        y = touch ? touch.clientY : 0;\n      }\n      if (event instanceof MouseEvent) {\n        x = event.clientX;\n        y = event.clientY;\n      }\n      return {\n        x,\n        y\n      };\n    }\n    /**\n     * Returns position of event when drag was started\n     */\n    fromEnter(event) {\n      return this.fromMovementNativeEvent(event);\n    }\n    /**\n     * Implements behaviour to detect drag events\n     */\n    forMove(initial) {\n      return this.move$.pipe(map(event => {\n        const positionBase = this.fromMovementNativeEvent(event);\n        return {\n          ...positionBase,\n          initial,\n          nativeEvent: event\n        };\n      }), takeUntil(this.leave$));\n    }\n  }\n  _defineProperty(DragService, \"\\u0275fac\", function DragService_Factory(t) {\n    return new (t || DragService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(WINDOW));\n  });\n  _defineProperty(DragService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DragService,\n    factory: DragService.ɵfac,\n    providedIn: 'root'\n  }));\n  return DragService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The directive that allows to drag HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet NgxDragDirective = /*#__PURE__*/(() => {\n  class NgxDragDirective extends BoundaryDirective {\n    /**\n     * Constrain for the dragging element.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxDragBoundary(boundary) {\n      this.boundary = boundary;\n    }\n    /**\n     * Emits changes when element was dragged\n     */\n\n    constructor(elementRef, renderer, dragService, window, document, platformId) {\n      super(window, document);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"dragService\", void 0);\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"document\", void 0);\n      _defineProperty(this, \"platformId\", void 0);\n      /**\n       * Initial size and position of host element\n       */\n      _defineProperty(this, \"hostElementRectInitial\", null);\n      /**\n       * Emits when directive was destroyed\n       */\n      _defineProperty(this, \"destroy$\", new Subject());\n      /**\n       * Emits when observable target was changed\n       */\n      _defineProperty(this, \"observableTargetChange$\", new Subject());\n      /**\n       * Define positioning strategy.\n       *\n       * 'free' - position will changing by 'transform: translate3d()' style\n       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n       *\n       * 'relative' - position will changing by 'top' and 'left' style\n       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n       *\n       * Default is 'free'.\n       */\n      _defineProperty(this, \"ngxDragPositionStrategy\", 'free');\n      /**\n       * Locks axis for the dragging\n       */\n      _defineProperty(this, \"ngxDragLockAxis\", null);\n      /**\n       * Disable any drag events\n       */\n      _defineProperty(this, \"ngxDragDisabled\", false);\n      _defineProperty(this, \"ngxDragged\", new EventEmitter());\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.dragService = dragService;\n      this.window = window;\n      this.document = document;\n      this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnInit() {\n      if (isPlatformServer(this.platformId)) {\n        return;\n      }\n      this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.observableTargetChange$.complete();\n    }\n    /**\n     * Observe the element dragging which will be as handle for dragging\n     */\n    observe(target = this.elementRef.nativeElement) {\n      this.observableTargetChange$.next(true);\n      let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      let eventInitial = null;\n      this.dragService.fromElement(target).pipe(tap(event => event.nativeEvent.preventDefault()), map(event => {\n        if (!eventInitial || eventInitial.x !== event.initial.x || eventInitial.y !== event.initial.y) {\n          eventInitial = event.initial;\n          hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n          if (!this.hostElementRectInitial) {\n            this.updateInitialRect();\n          }\n        }\n        const offsetFromHost = {\n          top: event.initial.y - hostElementRect.top,\n          left: event.initial.x - hostElementRect.left,\n          bottom: hostElementRect.bottom - event.initial.y,\n          right: hostElementRect.right - event.initial.x\n        };\n        return {\n          ...event,\n          initiator: target,\n          offsetFromHost,\n          initial: event.initial\n        };\n      }), tap(this.onDrag.bind(this)), takeUntil(this.destroy$), takeUntil(this.observableTargetChange$)).subscribe();\n    }\n    /**\n     * Update size and position of host element\n     */\n    updateInitialRect() {\n      if (!this.window) {\n        return;\n      }\n      const rect = this.elementRef.nativeElement.getBoundingClientRect();\n      this.hostElementRectInitial = {\n        left: this.window.scrollX + rect.left,\n        top: this.window.scrollY + rect.top\n      };\n    }\n    /**\n     * Starts the calculation of drag event and changes host position\n     */\n    onDrag(event) {\n      if (this.ngxDragDisabled) {\n        return;\n      }\n      const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      const boundaryRect = this.getBoundary();\n      let left = event.x - event.offsetFromHost.left;\n      let top = event.y - event.offsetFromHost.top;\n      if (boundaryRect) {\n        left = Math.max(boundaryRect.left, left);\n        left = Math.min(boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width, left);\n        top = Math.max(boundaryRect.top, top);\n        top = Math.min(boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height, top);\n      }\n      if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\n        left = left - this.hostElementRectInitial.left + this.window.scrollX;\n        top = top - this.hostElementRectInitial.top + this.window.scrollY;\n        if (this.ngxDragLockAxis === 'y') {\n          top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\n        }\n        if (this.ngxDragLockAxis === 'x') {\n          left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\n        }\n        this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\n        this.emitDrag(event.nativeEvent);\n        return;\n      }\n      if (this.ngxDragLockAxis === 'x') {\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.emitDrag(event.nativeEvent);\n        return;\n      }\n      if (this.ngxDragLockAxis === 'y') {\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.emitDrag(event.nativeEvent);\n        return;\n      }\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n      this.emitDrag(event.nativeEvent);\n    }\n    /**\n     * Updates the host style\n     */\n    updateHostStyle(style, value) {\n      this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Emits drag event to the {@link ngxDragged}\n     */\n    emitDrag(nativeEvent) {\n      const rect = this.elementRef.nativeElement.getBoundingClientRect();\n      this.ngxDragged.emit({\n        nativeEvent,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left\n      });\n    }\n  }\n  _defineProperty(NgxDragDirective, \"\\u0275fac\", function NgxDragDirective_Factory(t) {\n    return new (t || NgxDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  });\n  _defineProperty(NgxDragDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: NgxDragDirective,\n    selectors: [[\"\", \"ngxDrag\", \"\"]],\n    inputs: {\n      ngxDragPositionStrategy: \"ngxDragPositionStrategy\",\n      ngxDragLockAxis: \"ngxDragLockAxis\",\n      ngxDragDisabled: \"ngxDragDisabled\",\n      ngxDragBoundary: \"ngxDragBoundary\"\n    },\n    outputs: {\n      ngxDragged: \"ngxDragged\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return NgxDragDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet NgxDragHandleDirective = /*#__PURE__*/(() => {\n  class NgxDragHandleDirective {\n    constructor(elementRef, dragDirective, platformId) {\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"dragDirective\", void 0);\n      _defineProperty(this, \"platformId\", void 0);\n      this.elementRef = elementRef;\n      this.dragDirective = dragDirective;\n      this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n      this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n      this.observe();\n    }\n    /**\n     * Sets host element as observable point for {@link NgxDragDirective}\n     */\n    observe() {\n      if (isPlatformServer(this.platformId) || !this.dragDirective) {\n        return;\n      }\n      this.dragDirective.observe(this.elementRef.nativeElement);\n    }\n  }\n  _defineProperty(NgxDragHandleDirective, \"\\u0275fac\", function NgxDragHandleDirective_Factory(t) {\n    return new (t || NgxDragHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxDragDirective, 8), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  });\n  _defineProperty(NgxDragHandleDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: NgxDragHandleDirective,\n    selectors: [[\"\", \"ngxDragHandle\", \"\"]]\n  }));\n  return NgxDragHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar NgxResizeHandleType = /*#__PURE__*/(() => {\n  NgxResizeHandleType = NgxResizeHandleType || {};\n  NgxResizeHandleType[\"TopLeft\"] = \"top-left\";\n  NgxResizeHandleType[\"Top\"] = \"top\";\n  NgxResizeHandleType[\"TopRight\"] = \"top-right\";\n  NgxResizeHandleType[\"Right\"] = \"right\";\n  NgxResizeHandleType[\"BottomRight\"] = \"bottom-right\";\n  NgxResizeHandleType[\"Bottom\"] = \"bottom\";\n  NgxResizeHandleType[\"BottomLeft\"] = \"bottom-left\";\n  NgxResizeHandleType[\"Left\"] = \"left\";\n  return NgxResizeHandleType;\n})();\n/**\n * The directive that allows to resize HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet NgxResizeDirective = /*#__PURE__*/(() => {\n  class NgxResizeDirective extends BoundaryDirective {\n    /**\n     * Constrain of the resizing area.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxResizeBoundary(boundary) {\n      this.boundary = boundary;\n    }\n    /**\n     * A regular expression that matches with keyboard key code.\n     * When value is provided the element can be scaled by 'Key + wheel'.\n     * If value not provided the element can be scaled just by 'wheel'.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n     */\n    set ngxResizeWheelInitiatorRegExp(pattern) {\n      if (!pattern) {\n        this.wheelInitiatorRegExp = null;\n        this.subscribeForWheelEvent();\n        return;\n      }\n      this.wheelInitiatorRegExp = new RegExp(pattern);\n      this.subscribeForWheelEvent();\n    }\n    /**\n     * Disables resize by wheel.\n     * By default is 'false'.\n     */\n    set ngxResizeWheelDisabled(disabled) {\n      this.isWheelDisabled = disabled;\n      this.subscribeForWheelEvent();\n    }\n    /**\n     * Enables inversion for wheel event\n     */\n\n    /**\n     * Disables resize by touches.\n     * By default is 'false'.\n     * Resize work by using two fingers.\n     */\n    set ngxResizeTouchesDisabled(disabled) {\n      this.isTouchesDisabled = disabled;\n      this.subscribeForTouchEvents();\n    }\n    /**\n     * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\n     * Will be applied to host element.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     */\n\n    constructor(elementRef, renderer, dragService, document, window, platformId) {\n      super(window, document);\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"renderer\", void 0);\n      _defineProperty(this, \"dragService\", void 0);\n      _defineProperty(this, \"document\", void 0);\n      _defineProperty(this, \"window\", void 0);\n      _defineProperty(this, \"platformId\", void 0);\n      /**\n       * Emits when directive was destroyed\n       */\n      _defineProperty(this, \"destroy$\", new Subject());\n      /**\n       * Emits next every time when behaviour for wheel event was changed\n       */\n      _defineProperty(this, \"wheelBehaviourChange$\", new Subject());\n      /**\n       * Emits next every time when behaviour for touches event was changed\n       */\n      _defineProperty(this, \"touchBehaviourChange$\", new Subject());\n      /**\n       * An array of observers which affect on resizable element\n       */\n      _defineProperty(this, \"observers\", []);\n      /**\n       * A regular expression for keyboard code\n       */\n      _defineProperty(this, \"wheelInitiatorRegExp\", null);\n      /**\n       * Make a resize unavailable by wheel\n       */\n      _defineProperty(this, \"isWheelDisabled\", false);\n      /**\n       * Make a resize unavailable by touches\n       */\n      _defineProperty(this, \"isTouchesDisabled\", false);\n      /**\n       * Minimal width in px\n       */\n      _defineProperty(this, \"ngxResizeMinWidth\", 0);\n      /**\n       * Minimal height in px\n       */\n      _defineProperty(this, \"ngxResizeMinHeight\", 0);\n      /**\n       * Aspect ratio the element will use during resize\n       *\n       * @example\n       * 16/9 - 9/16 * 100 = 56.25\n       * 1/1 - 1/1 * 100 = 100\n       */\n      _defineProperty(this, \"ngxResizeAspectRatio\", 0);\n      /**\n       * Disables any resize events\n       */\n      _defineProperty(this, \"ngxResizeDisabled\", false);\n      /**\n       * Locks axis for the resize\n       */\n      _defineProperty(this, \"ngxResizeLockAxis\", null);\n      _defineProperty(this, \"ngxResizeWheelInverse\", false);\n      _defineProperty(this, \"ngxResizePosition\", 'absolute');\n      /**\n       * Emits changes when element was resized\n       */\n      _defineProperty(this, \"ngxResized\", new EventEmitter());\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.dragService = dragService;\n      this.document = document;\n      this.window = window;\n      this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n      if (isPlatformServer(this.platformId)) {\n        return;\n      }\n      this.initialResize();\n      this.subscribeForWheelEvent();\n      this.subscribeForTouchEvents();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n      this.destroy$.next(true);\n      this.destroy$.complete();\n      this.wheelBehaviourChange$.complete();\n      this.touchBehaviourChange$.complete();\n    }\n    /**\n     * Unsubscribe from the element dragging and remove it from an array of observable objects\n     */\n    unsubscribe(target) {\n      const indexOf = this.observers.findIndex(item => item.element === target);\n      if (indexOf < 0) {\n        return;\n      }\n      this.observers[indexOf].subscription.unsubscribe();\n      this.observers.splice(indexOf, 1);\n    }\n    /**\n     * Observe the element dragging which will be as handle for resize\n     */\n    observe(target) {\n      if (!this.resolveInitiatorType(target)) {\n        return;\n      }\n      let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      let eventInitial = null;\n      const subscription$ = this.dragService.fromElement(target).pipe(tap(event => event.nativeEvent.preventDefault()), tap(event => event.nativeEvent.stopImmediatePropagation()), map(event => {\n        if (!eventInitial || eventInitial.x !== event.initial.x || eventInitial.y !== event.initial.y) {\n          eventInitial = event.initial;\n          hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        }\n        const offsetFromHost = {\n          top: event.initial.y - hostElementRect.top,\n          left: event.initial.x - hostElementRect.left,\n          bottom: hostElementRect.bottom - event.initial.y,\n          right: hostElementRect.right - event.initial.x\n        };\n        return {\n          ...event,\n          initiator: target,\n          offsetFromHost,\n          initial: event.initial,\n          nativeEvent: event.nativeEvent\n        };\n      }), tap(this.onResize.bind(this)), takeUntil(this.destroy$)).subscribe();\n      this.observers.push({\n        subscription: subscription$,\n        element: target\n      });\n    }\n    /**\n     * Starts the subscription for touch events\n     */\n    subscribeForTouchEvents() {\n      this.touchBehaviourChange$.next(true);\n      if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\n        return;\n      }\n      let prevDistance = 0;\n      const touchStart$ = fromEvent(this.elementRef.nativeElement, 'touchstart').pipe(filter(event => event.targetTouches.length === 2));\n      const touchEnd$ = fromEvent(this.elementRef.nativeElement, 'touchend');\n      const touchMove$ = fromEvent(this.elementRef.nativeElement, 'touchmove', {\n        passive: false\n      }).pipe(tap(event => event.preventDefault()), filter(event => event.targetTouches.length === 2 && event.changedTouches.length === 2));\n      touchStart$.pipe(tap(event => {\n        const aTouch = event.targetTouches.item(0);\n        const bTouch = event.targetTouches.item(1);\n        if (!aTouch || !bTouch) {\n          return;\n        }\n        prevDistance = this.touchesDistance(aTouch, bTouch);\n      }), switchMap(() => touchMove$.pipe(tap(event => {\n        const aTouch = event.targetTouches.item(0);\n        const bTouch = event.targetTouches.item(1);\n        if (!aTouch || !bTouch) {\n          return;\n        }\n        const distance = this.touchesDistance(aTouch, bTouch);\n        this.onScale({\n          delta: distance - prevDistance\n        }, event);\n        prevDistance = distance;\n      }), takeUntil(touchEnd$))), takeUntil(this.destroy$), takeUntil(this.touchBehaviourChange$)).subscribe();\n    }\n    /**\n     * Returns distance between two touches\n     */\n    touchesDistance(a, b) {\n      return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\n    }\n    /**\n     * Make a subscription for wheel events\n     */\n    subscribeForWheelEvent() {\n      this.wheelBehaviourChange$.next(true);\n      if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\n        return;\n      }\n      const wheel$ = fromEvent(this.elementRef.nativeElement, 'wheel').pipe(tap(event => event.preventDefault()), tap(event => {\n        const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\n        this.onScale({\n          delta\n        }, event);\n      }), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$));\n      if (!this.wheelInitiatorRegExp) {\n        wheel$.subscribe();\n        return;\n      }\n      const wheelInitiatorFilter = filter(event => this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\n      const wheelInitiatorStart$ = fromEvent(this.window, 'keydown').pipe(wheelInitiatorFilter);\n      const wheelInitiatorEnd$ = fromEvent(this.window, 'keyup').pipe(wheelInitiatorFilter);\n      wheelInitiatorStart$.pipe(switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$)).subscribe();\n    }\n    /**\n     * Runs initial resize for the host element\n     */\n    initialResize() {\n      setTimeout(() => {\n        this.onScale({\n          delta: 0\n        });\n      });\n    }\n    /**\n     * Starts the calculation of scale event and changes host size\n     */\n    onScale(scale, nativeEvent) {\n      const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      const boundaryRect = this.getBoundary();\n      let maxUpscale = scale.delta;\n      if (boundaryRect) {\n        maxUpscale = Math.floor(Math.min(hostElementRect.top - boundaryRect.top, boundaryRect.right - hostElementRect.right, boundaryRect.bottom - hostElementRect.bottom, hostElementRect.left - boundaryRect.left));\n      }\n      const maxDownscale = Math.max(0, Math.min(hostElementRect.width - this.ngxResizeMinWidth, hostElementRect.height - this.ngxResizeMinHeight)) * -1;\n      const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\n      let top = hostElementRect.top - delta / 2;\n      let left = hostElementRect.left - delta / 2;\n      if (boundaryRect) {\n        top = Math.max(boundaryRect.top, top);\n        left = Math.max(boundaryRect.left, left);\n      }\n      let height = hostElementRect.height + delta;\n      let width = hostElementRect.width + delta;\n      if (boundaryRect) {\n        height = Math.min(boundaryRect.bottom - top, height);\n        width = Math.min(boundaryRect.right - left, width);\n      }\n      if (this.ngxResizeLockAxis === 'x') {\n        left = hostElementRect.left;\n        width = hostElementRect.width;\n      }\n      if (this.ngxResizeLockAxis === 'y') {\n        top = hostElementRect.top;\n        height = hostElementRect.height;\n      }\n      const proportionalSize = this.ngxResizeLockAxis === 'y' ? this.fromWidthProportion(width) : this.fromHeightProportion(height);\n      if (proportionalSize && this.ngxResizeLockAxis === 'y') {\n        height = proportionalSize;\n        top = hostElementRect.top - (height - hostElementRect.height) / 2;\n      }\n      if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\n        width = proportionalSize;\n        left = hostElementRect.left - (width - hostElementRect.width) / 2;\n      }\n      if (boundaryRect && (top <= boundaryRect.top || top + height >= boundaryRect.bottom || left <= boundaryRect.left || left + width >= boundaryRect.right)) {\n        top = hostElementRect.top;\n        height = hostElementRect.height;\n        left = hostElementRect.left;\n        width = hostElementRect.width;\n      }\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n      this.updateHostStyle('width', `${width}px`);\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n      this.updateHostStyle('height', `${height}px`);\n      this.emitResize(nativeEvent);\n    }\n    /**\n     * Check whether is resize is available for current initiator type\n     */\n    canResize(initiatorType) {\n      switch (initiatorType) {\n        case NgxResizeHandleType.TopLeft:\n        case NgxResizeHandleType.TopRight:\n        case NgxResizeHandleType.BottomLeft:\n        case NgxResizeHandleType.BottomRight:\n          return !this.ngxResizeLockAxis;\n        case NgxResizeHandleType.Left:\n        case NgxResizeHandleType.Right:\n          return this.ngxResizeLockAxis !== 'x';\n        case NgxResizeHandleType.Top:\n        case NgxResizeHandleType.Bottom:\n          return this.ngxResizeLockAxis !== 'y';\n      }\n      return !this.ngxResizeLockAxis;\n    }\n    /**\n     * Starts the calculation of resize event and changes host size\n     */\n    onResize(event) {\n      if (this.ngxResizeDisabled) {\n        return;\n      }\n      const initiatorType = this.resolveInitiatorType(event.initiator);\n      if (!initiatorType || !this.canResize(initiatorType)) {\n        return;\n      }\n      const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      const boundaryRect = this.getBoundary();\n      if (!boundaryRect) {\n        return;\n      }\n      switch (initiatorType) {\n        case NgxResizeHandleType.TopLeft:\n          return this.topLeftMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.Top:\n          return this.topMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.TopRight:\n          return this.topRightMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.Right:\n          return this.rightMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.BottomRight:\n          return this.bottomRightMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.Bottom:\n          return this.bottomMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.BottomLeft:\n          return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\n        case NgxResizeHandleType.Left:\n          return this.leftMovement(event, hostElementRect, boundaryRect);\n      }\n    }\n    topLeftMovement(event, hostElementRect, boundaryRect) {\n      if (this.ngxResizeAspectRatio) {\n        this.topMovement(event, hostElementRect, boundaryRect);\n        return;\n      }\n      this.topMovement(event, hostElementRect, boundaryRect);\n      this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topRightMovement(event, hostElementRect, boundaryRect) {\n      if (this.ngxResizeAspectRatio) {\n        this.topMovement(event, hostElementRect, boundaryRect);\n        return;\n      }\n      this.topMovement(event, hostElementRect, boundaryRect);\n      this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomRightMovement(event, hostElementRect, boundaryRect) {\n      if (this.ngxResizeAspectRatio) {\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        return;\n      }\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomLeftMovement(event, hostElementRect, boundaryRect) {\n      if (this.ngxResizeAspectRatio) {\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        return;\n      }\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topMovement(event, hostElementRect, boundaryRect) {\n      let y = event.y - event.offsetFromHost.top;\n      if (boundaryRect) {\n        y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n      }\n      let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\n      let height = hostElementRect.height - (top - hostElementRect.top);\n      const initiatorType = this.resolveInitiatorType(event.initiator);\n      const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n      if (widthProportions) {\n        top = top + (height - this.fromWidthProportion(widthProportions.width));\n        height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n      }\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n      this.updateHostStyle('height', `${height}px`);\n      if (widthProportions) {\n        this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n        this.updateHostStyle('width', `${widthProportions.width}px`);\n      }\n      this.emitResize(event.nativeEvent);\n    }\n    rightMovement(event, hostElementRect, boundaryRect) {\n      let x = event.x + event.offsetFromHost.right;\n      if (boundaryRect) {\n        x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n      }\n      let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\n      if (boundaryRect) {\n        width = Math.min(width, boundaryRect.right - hostElementRect.left);\n      }\n      const initiatorType = this.resolveInitiatorType(event.initiator);\n      const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n      if (heightProportions) {\n        width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n      }\n      this.updateHostStyle('width', `${width}px`);\n      if (heightProportions) {\n        this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n        this.updateHostStyle('height', `${heightProportions.height}px`);\n      }\n      this.emitResize(event.nativeEvent);\n    }\n    bottomMovement(event, hostElementRect, boundaryRect) {\n      let y = event.y + event.offsetFromHost.bottom;\n      if (boundaryRect) {\n        y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n      }\n      let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\n      if (boundaryRect) {\n        height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\n      }\n      const initiatorType = this.resolveInitiatorType(event.initiator);\n      const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n      if (widthProportions) {\n        height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n      }\n      this.updateHostStyle('height', `${height}px`);\n      if (widthProportions) {\n        this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n        this.updateHostStyle('width', `${widthProportions.width}px`);\n      }\n      this.emitResize(event.nativeEvent);\n    }\n    leftMovement(event, hostElementRect, boundaryRect) {\n      let x = event.x - event.offsetFromHost.left;\n      if (boundaryRect) {\n        x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n      }\n      let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\n      let width = hostElementRect.width - (left - hostElementRect.left);\n      const initiatorType = this.resolveInitiatorType(event.initiator);\n      const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n      if (heightProportions) {\n        left = left + (width - this.fromHeightProportion(heightProportions.height));\n        width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n      }\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n      this.updateHostStyle('width', `${width}px`);\n      if (heightProportions) {\n        this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n        this.updateHostStyle('height', `${heightProportions.height}px`);\n      }\n      this.emitResize(event.nativeEvent);\n    }\n    /**\n     * Get position and size of width\n     */\n    getWidthProportions(boundaryRect, hostElementRect, type, height) {\n      let width = this.fromHeightProportion(height);\n      if (!width) {\n        return null;\n      }\n      if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\n        width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\n      }\n      if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\n        width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\n      }\n      let left = hostElementRect.left;\n      if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\n        left = left - (width - hostElementRect.width);\n      }\n      if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\n        left = left - (width - hostElementRect.width) / 2;\n      }\n      return {\n        left,\n        width\n      };\n    }\n    /**\n     * Get position and size of height\n     */\n    getHeightProportions(boundaryRect, hostElementRect, type, width) {\n      let height = this.fromWidthProportion(width);\n      if (!height) {\n        return null;\n      }\n      if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\n        height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\n      }\n      if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\n        height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\n      }\n      let top = hostElementRect.top;\n      if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\n        top = top - (height - hostElementRect.height);\n      }\n      if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\n        top = top - (height - hostElementRect.height) / 2;\n      }\n      return {\n        top,\n        height\n      };\n    }\n    /**\n     * Get width based on {@link ngxResizeAspectRatio} from height\n     */\n    fromHeightProportion(height) {\n      return !this.ngxResizeAspectRatio ? 0 : Math.floor(height / this.ngxResizeAspectRatio * 100);\n    }\n    /**\n     * Get height based on {@link ngxResizeAspectRatio} from width\n     */\n    fromWidthProportion(width) {\n      return !this.ngxResizeAspectRatio ? 0 : Math.floor(width * this.ngxResizeAspectRatio / 100);\n    }\n    /**\n     * Updates host element style\n     */\n    updateHostStyle(style, value) {\n      this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Resolves the type of handle HTML element\n     */\n    resolveInitiatorType(initiator) {\n      return initiator.getAttribute('data-ngx-resize-handle-type');\n    }\n    /**\n     * Emits resize event to the {@link ngxResized}\n     */\n    emitResize(nativeEvent) {\n      const rect = this.elementRef.nativeElement.getBoundingClientRect();\n      this.ngxResized.emit({\n        nativeEvent,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left\n      });\n    }\n  }\n  _defineProperty(NgxResizeDirective, \"\\u0275fac\", function NgxResizeDirective_Factory(t) {\n    return new (t || NgxResizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(PLATFORM_ID));\n  });\n  _defineProperty(NgxResizeDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: NgxResizeDirective,\n    selectors: [[\"\", \"ngxResize\", \"\"]],\n    hostVars: 2,\n    hostBindings: function NgxResizeDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"position\", ctx.ngxResizePosition);\n      }\n    },\n    inputs: {\n      ngxResizeMinWidth: \"ngxResizeMinWidth\",\n      ngxResizeMinHeight: \"ngxResizeMinHeight\",\n      ngxResizeAspectRatio: \"ngxResizeAspectRatio\",\n      ngxResizeDisabled: \"ngxResizeDisabled\",\n      ngxResizeLockAxis: \"ngxResizeLockAxis\",\n      ngxResizeBoundary: \"ngxResizeBoundary\",\n      ngxResizeWheelInitiatorRegExp: \"ngxResizeWheelInitiatorRegExp\",\n      ngxResizeWheelDisabled: \"ngxResizeWheelDisabled\",\n      ngxResizeWheelInverse: \"ngxResizeWheelInverse\",\n      ngxResizeTouchesDisabled: \"ngxResizeTouchesDisabled\",\n      ngxResizePosition: \"ngxResizePosition\"\n    },\n    outputs: {\n      ngxResized: \"ngxResized\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature]\n  }));\n  return NgxResizeDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nlet NgxResizeHandleDirective = /*#__PURE__*/(() => {\n  class NgxResizeHandleDirective {\n    constructor(elementRef, platformId, resizeDirective) {\n      _defineProperty(this, \"elementRef\", void 0);\n      _defineProperty(this, \"platformId\", void 0);\n      _defineProperty(this, \"resizeDirective\", void 0);\n      /**\n       * Sets the attribute which define the side the HTML element will affect during drag\n       */\n      _defineProperty(this, \"type\", null);\n      this.elementRef = elementRef;\n      this.platformId = platformId;\n      this.resizeDirective = resizeDirective;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n      if (isPlatformServer(this.platformId) || !this.resizeDirective) {\n        return;\n      }\n      this.resizeDirective.observe(this.elementRef.nativeElement);\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n      if (!this.resizeDirective) {\n        return;\n      }\n      this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\n    }\n  }\n  _defineProperty(NgxResizeHandleDirective, \"\\u0275fac\", function NgxResizeHandleDirective_Factory(t) {\n    return new (t || NgxResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(NgxResizeDirective, 8));\n  });\n  _defineProperty(NgxResizeHandleDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: NgxResizeHandleDirective,\n    selectors: [[\"\", \"ngxResizeHandle\", \"\"]],\n    hostVars: 1,\n    hostBindings: function NgxResizeHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"data-ngx-resize-handle-type\", ctx.type);\n      }\n    },\n    inputs: {\n      type: [\"ngxResizeHandle\", \"type\"]\n    }\n  }));\n  return NgxResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n */\nlet SharedModule = /*#__PURE__*/(() => {\n  class SharedModule {}\n  _defineProperty(SharedModule, \"\\u0275fac\", function SharedModule_Factory(t) {\n    return new (t || SharedModule)();\n  });\n  _defineProperty(SharedModule, \"\\u0275mod\", /*@__PURE__*/i0.ɵɵdefineNgModule({\n    type: SharedModule\n  }));\n  _defineProperty(SharedModule, \"\\u0275inj\", /*@__PURE__*/i0.ɵɵdefineInjector({}));\n  return SharedModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(SharedModule, {\n    declarations: [BoundaryDirective],\n    exports: [BoundaryDirective]\n  });\n})();\n\n/**\n * The module provides opportunity to use drag and resize functionality on HTML elements\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n */\nlet NgxDragResizeModule = /*#__PURE__*/(() => {\n  class NgxDragResizeModule {}\n  _defineProperty(NgxDragResizeModule, \"\\u0275fac\", function NgxDragResizeModule_Factory(t) {\n    return new (t || NgxDragResizeModule)();\n  });\n  _defineProperty(NgxDragResizeModule, \"\\u0275mod\", /*@__PURE__*/i0.ɵɵdefineNgModule({\n    type: NgxDragResizeModule\n  }));\n  _defineProperty(NgxDragResizeModule, \"\\u0275inj\", /*@__PURE__*/i0.ɵɵdefineInjector({\n    imports: [SharedModule]\n  }));\n  return NgxDragResizeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxDragResizeModule, {\n    declarations: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective],\n    imports: [SharedModule],\n    exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n  });\n})();\n\n/*\n * Public API Surface of ngx-drag-resize\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxDragDirective, NgxDragHandleDirective, NgxDragResizeModule, NgxResizeDirective, NgxResizeHandleDirective, NgxResizeHandleType };\n//# sourceMappingURL=ngx-drag-resize.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}