{"hash":"646b000b5af7e74d0d46f2f47bb2aa45681064b3","fesm2022":[{"exports":["NgxDragDirective","NgxDragHandleDirective","NgxDragResizeModule","NgxResizeDirective","NgxResizeHandleDirective","NgxResizeHandleType"],"facadeModuleId":"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/ngx-drag-resize.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/shared/boundary/boundary.directive.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/core/window.token.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/core/drag.service.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag.directive.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag-handle.directive.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize-handle-type.enum.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize.directive.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize-handle.directive.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/shared/shared.module.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag-resize.module.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/public-api.mjs","/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/ngx-drag-resize.mjs"],"name":"ngx-drag-resize","type":"chunk","dynamicImports":[],"fileName":"ngx-drag-resize.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","Directive","InjectionToken","Injectable","Inject","EventEmitter","PLATFORM_ID","Input","Output","Optional","HostBinding","NgModule"],"rxjs":["merge","fromEvent","EMPTY","Subject"],"rxjs/operators":["tap","map","switchMap","takeUntil","filter"],"@angular/common":["DOCUMENT","isPlatformServer"]},"imports":["@angular/core","rxjs","rxjs/operators","@angular/common"],"modules":{"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/shared/boundary/boundary.directive.mjs":{"code":"/**\n * The directive is used to work with boundary area for HTML element\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass BoundaryDirective {\n    windowObject;\n    documentObject;\n    /**\n     * CSS selector or HTML element\n     */\n    boundary = null;\n    constructor(windowObject, documentObject) {\n        this.windowObject = windowObject;\n        this.documentObject = documentObject;\n    }\n    /**\n     * Get boundary position based on {@link boundary}\n     */\n    getBoundary() {\n        const rect = {};\n        const boundaryElement = this.resolveBoundaryElement();\n        if (boundaryElement instanceof Element) {\n            const boundaryElementRect = boundaryElement.getBoundingClientRect();\n            rect.left = boundaryElementRect.left;\n            rect.top = boundaryElementRect.top;\n            rect.bottom = boundaryElementRect.bottom;\n            rect.right = boundaryElementRect.right;\n            return rect;\n        }\n        if (boundaryElement instanceof Window && this.windowObject) {\n            rect.top = 0;\n            rect.left = 0;\n            rect.right = this.windowObject.innerWidth;\n            rect.bottom = this.windowObject.innerHeight;\n            return rect;\n        }\n        return null;\n    }\n    /**\n     * Resolves HTML element based on {@link boundary}\n     */\n    resolveBoundaryElement() {\n        if (!this.boundary) {\n            return null;\n        }\n        if (this.boundary === 'window' && this.windowObject) {\n            return this.windowObject;\n        }\n        if (typeof this.boundary === 'string') {\n            return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\n        }\n        return this.boundary;\n    }\n    /**\n     * Returns positional value based on boundary position\n     */\n    basedOnBoundary(value, position) {\n        const boundary = this.getBoundary();\n        if (!boundary) {\n            return value;\n        }\n        switch (position) {\n            case 'left':\n                return value - boundary.left;\n            case 'top':\n                return value - boundary.top;\n        }\n        return value;\n    }\n    static ɵfac = function BoundaryDirective_Factory(t) { return new (t || BoundaryDirective)(i0.ɵɵdirectiveInject(Window), i0.ɵɵdirectiveInject(Document)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: BoundaryDirective, selectors: [[\"\", \"ngxBoundary\", \"\"]] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BoundaryDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxBoundary]',\n            }]\n    }], function () { return [{ type: Window }, { type: Document }]; }, null); })();","originalLength":8704,"removedExports":[],"renderedExports":["BoundaryDirective"],"renderedLength":2843},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/core/window.token.mjs":{"code":"/**\n * A DI Token representing the window object.\n *\n * Note: might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\n *\n * @internal\n */\nconst WINDOW = new InjectionToken('lib.window', {\n    factory: () => (typeof window !== 'undefined' ? window : null)\n});","originalLength":1641,"removedExports":[],"renderedExports":["WINDOW"],"renderedLength":375},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/core/drag.service.mjs":{"code":"/**\n * The service that allows to observe the element dragging\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass DragService {\n    document;\n    window;\n    /**\n     * Emits on mouse or touch event was ended\n     */\n    leave$ = merge(\n    // fromEvent<MovementNative>(this.document, 'mouseup'),\n    // fromEvent<MovementNative>(this.document, 'touchend')\n    );\n    /**\n     * Emits on mouse or touch move\n     */\n    move$ = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));\n    constructor(document, window) {\n        this.document = document;\n        this.window = window;\n    }\n    /**\n     * Creates an observable that emits drag event\n     */\n    fromElement(target) {\n        if (!this.document) {\n            return EMPTY;\n        }\n        const enter$ = merge(fromEvent(target, 'mousedown'), fromEvent(target, 'touchstart'));\n        return enter$.pipe(tap((event) => event.preventDefault()), map((event) => this.fromEnter(event)), switchMap((event) => this.forMove(event)));\n    }\n    /**\n     * Returns position of mouse or touch event\n     */\n    fromMovementNativeEvent(event) {\n        let x = 0;\n        let y = 0;\n        if (!this.window) {\n            return { x, y };\n        }\n        if ('TouchEvent' in this.window && event instanceof TouchEvent) {\n            const touch = event.touches.length ? event.touches.item(0) : null;\n            x = touch ? touch.clientX : 0;\n            y = touch ? touch.clientY : 0;\n        }\n        if (event instanceof MouseEvent) {\n            x = event.clientX;\n            y = event.clientY;\n        }\n        return { x, y };\n    }\n    /**\n     * Returns position of event when drag was started\n     */\n    fromEnter(event) {\n        return this.fromMovementNativeEvent(event);\n    }\n    /**\n     * Implements behaviour to detect drag events\n     */\n    forMove(initial) {\n        return this.move$.pipe(map((event) => {\n            const positionBase = this.fromMovementNativeEvent(event);\n            return {\n                ...positionBase,\n                initial,\n                nativeEvent: event,\n            };\n        }), takeUntil(this.leave$));\n    }\n    static ɵfac = function DragService_Factory(t) { return new (t || DragService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(WINDOW)); };\n    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DragService, factory: DragService.ɵfac, providedIn: 'root' });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root',\n            }]\n    }], function () { return [{ type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }]; }, null); })();","originalLength":10757,"removedExports":[],"renderedExports":["DragService"],"renderedLength":3015},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag.directive.mjs":{"code":"/**\n * The directive that allows to drag HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragDirective extends BoundaryDirective {\n    elementRef;\n    renderer;\n    dragService;\n    window;\n    document;\n    platformId;\n    /**\n     * Initial size and position of host element\n     */\n    hostElementRectInitial = null;\n    /**\n     * Emits when directive was destroyed\n     */\n    destroy$ = new Subject();\n    /**\n     * Emits when observable target was changed\n     */\n    observableTargetChange$ = new Subject();\n    /**\n     * Define positioning strategy.\n     *\n     * 'free' - position will changing by 'transform: translate3d()' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n     *\n     * 'relative' - position will changing by 'top' and 'left' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     *\n     * Default is 'free'.\n     */\n    ngxDragPositionStrategy = 'free';\n    /**\n     * Locks axis for the dragging\n     */\n    ngxDragLockAxis = null;\n    /**\n     * Disable any drag events\n     */\n    ngxDragDisabled = false;\n    /**\n     * Constrain for the dragging element.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxDragBoundary(boundary) {\n        this.boundary = boundary;\n    }\n    /**\n     * Emits changes when element was dragged\n     */\n    ngxDragged = new EventEmitter();\n    constructor(elementRef, renderer, dragService, window, document, platformId) {\n        console.log('[DragDirective] constructed', window, document);\n        super(window, document);\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.dragService = dragService;\n        this.window = window;\n        this.document = document;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnInit() {\n        if (isPlatformServer(this.platformId)) {\n            return;\n        }\n        this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.destroy$.next(true);\n        this.destroy$.complete();\n        this.observableTargetChange$.complete();\n    }\n    /**\n     * Observe the element dragging which will be as handle for dragging\n     */\n    observe(target = this.elementRef.nativeElement) {\n        this.observableTargetChange$.next(true);\n        let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        let eventInitial = null;\n        this.dragService\n            .fromElement(target)\n            .pipe(tap((event) => event.nativeEvent.preventDefault()), map((event) => {\n            if (!eventInitial ||\n                eventInitial.x !== event.initial.x ||\n                eventInitial.y !== event.initial.y) {\n                eventInitial = event.initial;\n                hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n                if (!this.hostElementRectInitial) {\n                    this.updateInitialRect();\n                }\n            }\n            const offsetFromHost = {\n                top: event.initial.y - hostElementRect.top,\n                left: event.initial.x - hostElementRect.left,\n                bottom: hostElementRect.bottom - event.initial.y,\n                right: hostElementRect.right - event.initial.x,\n            };\n            return {\n                ...event,\n                initiator: target,\n                offsetFromHost,\n                initial: event.initial,\n            };\n        }), tap(this.onDrag.bind(this)), takeUntil(this.destroy$), takeUntil(this.observableTargetChange$))\n            .subscribe();\n    }\n    /**\n     * Update size and position of host element\n     */\n    updateInitialRect() {\n        if (!this.window) {\n            return;\n        }\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.hostElementRectInitial = {\n            left: this.window.scrollX + rect.left,\n            top: this.window.scrollY + rect.top,\n        };\n    }\n    /**\n     * Starts the calculation of drag event and changes host position\n     */\n    onDrag(event) {\n        if (this.ngxDragDisabled) {\n            return;\n        }\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        let left = event.x - event.offsetFromHost.left;\n        let top = event.y - event.offsetFromHost.top;\n        if (boundaryRect) {\n            left = Math.max(boundaryRect.left, left);\n            left = Math.min(boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width, left);\n            top = Math.max(boundaryRect.top, top);\n            top = Math.min(boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height, top);\n        }\n        if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\n            left = left - this.hostElementRectInitial.left + this.window.scrollX;\n            top = top - this.hostElementRectInitial.top + this.window.scrollY;\n            if (this.ngxDragLockAxis === 'y') {\n                top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\n            }\n            if (this.ngxDragLockAxis === 'x') {\n                left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\n            }\n            this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        if (this.ngxDragLockAxis === 'x') {\n            this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        if (this.ngxDragLockAxis === 'y') {\n            this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.emitDrag(event.nativeEvent);\n    }\n    /**\n     * Updates the host style\n     */\n    updateHostStyle(style, value) {\n        this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Emits drag event to the {@link ngxDragged}\n     */\n    emitDrag(nativeEvent) {\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.ngxDragged.emit({\n            nativeEvent,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            left: rect.left,\n        });\n    }\n    static ɵfac = function NgxDragDirective_Factory(t) { return new (t || NgxDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxDragDirective, selectors: [[\"\", \"ngxDrag\", \"\"]], inputs: { ngxDragPositionStrategy: \"ngxDragPositionStrategy\", ngxDragLockAxis: \"ngxDragLockAxis\", ngxDragDisabled: \"ngxDragDisabled\", ngxDragBoundary: \"ngxDragBoundary\" }, outputs: { ngxDragged: \"ngxDragged\" }, features: [i0.ɵɵInheritDefinitionFeature] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxDrag]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragService }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ngxDragPositionStrategy: [{\n            type: Input\n        }], ngxDragLockAxis: [{\n            type: Input\n        }], ngxDragDisabled: [{\n            type: Input\n        }], ngxDragBoundary: [{\n            type: Input\n        }], ngxDragged: [{\n            type: Output\n        }] }); })();","originalLength":27678,"removedExports":[],"renderedExports":["NgxDragDirective"],"renderedLength":8507},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag-handle.directive.mjs":{"code":"/**\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragHandleDirective {\n    elementRef;\n    dragDirective;\n    platformId;\n    constructor(elementRef, dragDirective, platformId) {\n        this.elementRef = elementRef;\n        this.dragDirective = dragDirective;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.observe();\n    }\n    /**\n     * Sets host element as observable point for {@link NgxDragDirective}\n     */\n    observe() {\n        if (isPlatformServer(this.platformId) || !this.dragDirective) {\n            return;\n        }\n        this.dragDirective.observe(this.elementRef.nativeElement);\n    }\n    static ɵfac = function NgxDragHandleDirective_Factory(t) { return new (t || NgxDragHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxDragDirective, 8), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxDragHandleDirective, selectors: [[\"\", \"ngxDragHandle\", \"\"]] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragHandleDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxDragHandle]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: NgxDragDirective, decorators: [{\n                type: Optional\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();","originalLength":5169,"removedExports":[],"renderedExports":["NgxDragHandleDirective"],"renderedLength":1837},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize-handle-type.enum.mjs":{"code":"var NgxResizeHandleType;\n(function (NgxResizeHandleType) {\n    NgxResizeHandleType[\"TopLeft\"] = \"top-left\";\n    NgxResizeHandleType[\"Top\"] = \"top\";\n    NgxResizeHandleType[\"TopRight\"] = \"top-right\";\n    NgxResizeHandleType[\"Right\"] = \"right\";\n    NgxResizeHandleType[\"BottomRight\"] = \"bottom-right\";\n    NgxResizeHandleType[\"Bottom\"] = \"bottom\";\n    NgxResizeHandleType[\"BottomLeft\"] = \"bottom-left\";\n    NgxResizeHandleType[\"Left\"] = \"left\";\n})(NgxResizeHandleType || (NgxResizeHandleType = {}));","originalLength":1435,"removedExports":[],"renderedExports":["NgxResizeHandleType"],"renderedLength":497},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize.directive.mjs":{"code":"/**\n * The directive that allows to resize HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeDirective extends BoundaryDirective {\n    elementRef;\n    renderer;\n    dragService;\n    document;\n    window;\n    platformId;\n    /**\n     * Emits when directive was destroyed\n     */\n    destroy$ = new Subject();\n    /**\n     * Emits next every time when behaviour for wheel event was changed\n     */\n    wheelBehaviourChange$ = new Subject();\n    /**\n     * Emits next every time when behaviour for touches event was changed\n     */\n    touchBehaviourChange$ = new Subject();\n    /**\n     * An array of observers which affect on resizable element\n     */\n    observers = [];\n    /**\n     * A regular expression for keyboard code\n     */\n    wheelInitiatorRegExp = null;\n    /**\n     * Make a resize unavailable by wheel\n     */\n    isWheelDisabled = false;\n    /**\n     * Make a resize unavailable by touches\n     */\n    isTouchesDisabled = false;\n    /**\n     * Minimal width in px\n     */\n    ngxResizeMinWidth = 0;\n    /**\n     * Minimal height in px\n     */\n    ngxResizeMinHeight = 0;\n    /**\n     * Aspect ratio the element will use during resize\n     *\n     * @example\n     * 16/9 - 9/16 * 100 = 56.25\n     * 1/1 - 1/1 * 100 = 100\n     */\n    ngxResizeAspectRatio = 0;\n    /**\n     * Disables any resize events\n     */\n    ngxResizeDisabled = false;\n    /**\n     * Locks axis for the resize\n     */\n    ngxResizeLockAxis = null;\n    /**\n     * Constrain of the resizing area.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxResizeBoundary(boundary) {\n        this.boundary = boundary;\n    }\n    /**\n     * A regular expression that matches with keyboard key code.\n     * When value is provided the element can be scaled by 'Key + wheel'.\n     * If value not provided the element can be scaled just by 'wheel'.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n     */\n    set ngxResizeWheelInitiatorRegExp(pattern) {\n        if (!pattern) {\n            this.wheelInitiatorRegExp = null;\n            this.subscribeForWheelEvent();\n            return;\n        }\n        this.wheelInitiatorRegExp = new RegExp(pattern);\n        this.subscribeForWheelEvent();\n    }\n    /**\n     * Disables resize by wheel.\n     * By default is 'false'.\n     */\n    set ngxResizeWheelDisabled(disabled) {\n        this.isWheelDisabled = disabled;\n        this.subscribeForWheelEvent();\n    }\n    /**\n     * Enables inversion for wheel event\n     */\n    ngxResizeWheelInverse = false;\n    /**\n     * Disables resize by touches.\n     * By default is 'false'.\n     * Resize work by using two fingers.\n     */\n    set ngxResizeTouchesDisabled(disabled) {\n        this.isTouchesDisabled = disabled;\n        this.subscribeForTouchEvents();\n    }\n    /**\n     * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\n     * Will be applied to host element.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     */\n    ngxResizePosition = 'absolute';\n    /**\n     * Emits changes when element was resized\n     */\n    ngxResized = new EventEmitter();\n    constructor(elementRef, renderer, dragService, document, window, platformId) {\n        super(window, document);\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.dragService = dragService;\n        this.document = document;\n        this.window = window;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        if (isPlatformServer(this.platformId)) {\n            return;\n        }\n        this.initialResize();\n        this.subscribeForWheelEvent();\n        this.subscribeForTouchEvents();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.destroy$.next(true);\n        this.destroy$.complete();\n        this.wheelBehaviourChange$.complete();\n        this.touchBehaviourChange$.complete();\n    }\n    /**\n     * Unsubscribe from the element dragging and remove it from an array of observable objects\n     */\n    unsubscribe(target) {\n        const indexOf = this.observers.findIndex((item) => item.element === target);\n        if (indexOf < 0) {\n            return;\n        }\n        this.observers[indexOf].subscription.unsubscribe();\n        this.observers.splice(indexOf, 1);\n    }\n    /**\n     * Observe the element dragging which will be as handle for resize\n     */\n    observe(target) {\n        if (!this.resolveInitiatorType(target)) {\n            return;\n        }\n        let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        let eventInitial = null;\n        const subscription$ = this.dragService\n            .fromElement(target)\n            .pipe(tap((event) => event.nativeEvent.preventDefault()), tap((event) => event.nativeEvent.stopImmediatePropagation()), map((event) => {\n            if (!eventInitial ||\n                eventInitial.x !== event.initial.x ||\n                eventInitial.y !== event.initial.y) {\n                eventInitial = event.initial;\n                hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n            }\n            const offsetFromHost = {\n                top: event.initial.y - hostElementRect.top,\n                left: event.initial.x - hostElementRect.left,\n                bottom: hostElementRect.bottom - event.initial.y,\n                right: hostElementRect.right - event.initial.x,\n            };\n            return {\n                ...event,\n                initiator: target,\n                offsetFromHost,\n                initial: event.initial,\n                nativeEvent: event.nativeEvent,\n            };\n        }), tap(this.onResize.bind(this)), takeUntil(this.destroy$))\n            .subscribe();\n        this.observers.push({ subscription: subscription$, element: target });\n    }\n    /**\n     * Starts the subscription for touch events\n     */\n    subscribeForTouchEvents() {\n        this.touchBehaviourChange$.next(true);\n        if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\n            return;\n        }\n        let prevDistance = 0;\n        const touchStart$ = fromEvent(this.elementRef.nativeElement, 'touchstart').pipe(filter((event) => event.targetTouches.length === 2));\n        const touchEnd$ = fromEvent(this.elementRef.nativeElement, 'touchend');\n        const touchMove$ = fromEvent(this.elementRef.nativeElement, 'touchmove', {\n            passive: false,\n        }).pipe(tap((event) => event.preventDefault()), filter((event) => event.targetTouches.length === 2 && event.changedTouches.length === 2));\n        touchStart$\n            .pipe(tap((event) => {\n            const aTouch = event.targetTouches.item(0);\n            const bTouch = event.targetTouches.item(1);\n            if (!aTouch || !bTouch) {\n                return;\n            }\n            prevDistance = this.touchesDistance(aTouch, bTouch);\n        }), switchMap(() => touchMove$.pipe(tap((event) => {\n            const aTouch = event.targetTouches.item(0);\n            const bTouch = event.targetTouches.item(1);\n            if (!aTouch || !bTouch) {\n                return;\n            }\n            const distance = this.touchesDistance(aTouch, bTouch);\n            this.onScale({ delta: distance - prevDistance }, event);\n            prevDistance = distance;\n        }), takeUntil(touchEnd$))), takeUntil(this.destroy$), takeUntil(this.touchBehaviourChange$))\n            .subscribe();\n    }\n    /**\n     * Returns distance between two touches\n     */\n    touchesDistance(a, b) {\n        return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\n    }\n    /**\n     * Make a subscription for wheel events\n     */\n    subscribeForWheelEvent() {\n        this.wheelBehaviourChange$.next(true);\n        if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\n            return;\n        }\n        const wheel$ = fromEvent(this.elementRef.nativeElement, 'wheel').pipe(tap((event) => event.preventDefault()), tap((event) => {\n            const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\n            this.onScale({ delta }, event);\n        }), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$));\n        if (!this.wheelInitiatorRegExp) {\n            wheel$.subscribe();\n            return;\n        }\n        const wheelInitiatorFilter = filter((event) => this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\n        const wheelInitiatorStart$ = fromEvent(this.window, 'keydown').pipe(wheelInitiatorFilter);\n        const wheelInitiatorEnd$ = fromEvent(this.window, 'keyup').pipe(wheelInitiatorFilter);\n        wheelInitiatorStart$\n            .pipe(switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$))\n            .subscribe();\n    }\n    /**\n     * Runs initial resize for the host element\n     */\n    initialResize() {\n        setTimeout(() => {\n            this.onScale({ delta: 0 });\n        });\n    }\n    /**\n     * Starts the calculation of scale event and changes host size\n     */\n    onScale(scale, nativeEvent) {\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        let maxUpscale = scale.delta;\n        if (boundaryRect) {\n            maxUpscale = Math.floor(Math.min(hostElementRect.top - boundaryRect.top, boundaryRect.right - hostElementRect.right, boundaryRect.bottom - hostElementRect.bottom, hostElementRect.left - boundaryRect.left));\n        }\n        const maxDownscale = Math.max(0, Math.min(hostElementRect.width - this.ngxResizeMinWidth, hostElementRect.height - this.ngxResizeMinHeight)) * -1;\n        const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\n        let top = hostElementRect.top - delta / 2;\n        let left = hostElementRect.left - delta / 2;\n        if (boundaryRect) {\n            top = Math.max(boundaryRect.top, top);\n            left = Math.max(boundaryRect.left, left);\n        }\n        let height = hostElementRect.height + delta;\n        let width = hostElementRect.width + delta;\n        if (boundaryRect) {\n            height = Math.min(boundaryRect.bottom - top, height);\n            width = Math.min(boundaryRect.right - left, width);\n        }\n        if (this.ngxResizeLockAxis === 'x') {\n            left = hostElementRect.left;\n            width = hostElementRect.width;\n        }\n        if (this.ngxResizeLockAxis === 'y') {\n            top = hostElementRect.top;\n            height = hostElementRect.height;\n        }\n        const proportionalSize = this.ngxResizeLockAxis === 'y'\n            ? this.fromWidthProportion(width)\n            : this.fromHeightProportion(height);\n        if (proportionalSize && this.ngxResizeLockAxis === 'y') {\n            height = proportionalSize;\n            top = hostElementRect.top - (height - hostElementRect.height) / 2;\n        }\n        if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\n            width = proportionalSize;\n            left = hostElementRect.left - (width - hostElementRect.width) / 2;\n        }\n        if (boundaryRect &&\n            (top <= boundaryRect.top ||\n                top + height >= boundaryRect.bottom ||\n                left <= boundaryRect.left ||\n                left + width >= boundaryRect.right)) {\n            top = hostElementRect.top;\n            height = hostElementRect.height;\n            left = hostElementRect.left;\n            width = hostElementRect.width;\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('width', `${width}px`);\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.updateHostStyle('height', `${height}px`);\n        this.emitResize(nativeEvent);\n    }\n    /**\n     * Check whether is resize is available for current initiator type\n     */\n    canResize(initiatorType) {\n        switch (initiatorType) {\n            case NgxResizeHandleType.TopLeft:\n            case NgxResizeHandleType.TopRight:\n            case NgxResizeHandleType.BottomLeft:\n            case NgxResizeHandleType.BottomRight:\n                return !this.ngxResizeLockAxis;\n            case NgxResizeHandleType.Left:\n            case NgxResizeHandleType.Right:\n                return this.ngxResizeLockAxis !== 'x';\n            case NgxResizeHandleType.Top:\n            case NgxResizeHandleType.Bottom:\n                return this.ngxResizeLockAxis !== 'y';\n        }\n        return !this.ngxResizeLockAxis;\n    }\n    /**\n     * Starts the calculation of resize event and changes host size\n     */\n    onResize(event) {\n        if (this.ngxResizeDisabled) {\n            return;\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        if (!initiatorType || !this.canResize(initiatorType)) {\n            return;\n        }\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        if (!boundaryRect) {\n            return;\n        }\n        switch (initiatorType) {\n            case NgxResizeHandleType.TopLeft:\n                return this.topLeftMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Top:\n                return this.topMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.TopRight:\n                return this.topRightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Right:\n                return this.rightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.BottomRight:\n                return this.bottomRightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Bottom:\n                return this.bottomMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.BottomLeft:\n                return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Left:\n                return this.leftMovement(event, hostElementRect, boundaryRect);\n        }\n    }\n    topLeftMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.topMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.topMovement(event, hostElementRect, boundaryRect);\n        this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topRightMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.topMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.topMovement(event, hostElementRect, boundaryRect);\n        this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomRightMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.bottomMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomLeftMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.bottomMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topMovement(event, hostElementRect, boundaryRect) {\n        let y = event.y - event.offsetFromHost.top;\n        if (boundaryRect) {\n            y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n        }\n        let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\n        let height = hostElementRect.height - (top - hostElementRect.top);\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n        if (widthProportions) {\n            top = top + (height - this.fromWidthProportion(widthProportions.width));\n            height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n        }\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.updateHostStyle('height', `${height}px`);\n        if (widthProportions) {\n            this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n            this.updateHostStyle('width', `${widthProportions.width}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    rightMovement(event, hostElementRect, boundaryRect) {\n        let x = event.x + event.offsetFromHost.right;\n        if (boundaryRect) {\n            x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n        }\n        let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\n        if (boundaryRect) {\n            width = Math.min(width, boundaryRect.right - hostElementRect.left);\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n        if (heightProportions) {\n            width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n        }\n        this.updateHostStyle('width', `${width}px`);\n        if (heightProportions) {\n            this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n            this.updateHostStyle('height', `${heightProportions.height}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    bottomMovement(event, hostElementRect, boundaryRect) {\n        let y = event.y + event.offsetFromHost.bottom;\n        if (boundaryRect) {\n            y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n        }\n        let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\n        if (boundaryRect) {\n            height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n        if (widthProportions) {\n            height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n        }\n        this.updateHostStyle('height', `${height}px`);\n        if (widthProportions) {\n            this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n            this.updateHostStyle('width', `${widthProportions.width}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    leftMovement(event, hostElementRect, boundaryRect) {\n        let x = event.x - event.offsetFromHost.left;\n        if (boundaryRect) {\n            x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n        }\n        let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\n        let width = hostElementRect.width - (left - hostElementRect.left);\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n        if (heightProportions) {\n            left = left + (width - this.fromHeightProportion(heightProportions.height));\n            width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('width', `${width}px`);\n        if (heightProportions) {\n            this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n            this.updateHostStyle('height', `${heightProportions.height}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    /**\n     * Get position and size of width\n     */\n    getWidthProportions(boundaryRect, hostElementRect, type, height) {\n        let width = this.fromHeightProportion(height);\n        if (!width) {\n            return null;\n        }\n        if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\n            width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\n        }\n        if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\n            width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\n        }\n        let left = hostElementRect.left;\n        if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\n            left = left - (width - hostElementRect.width);\n        }\n        if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\n            left = left - (width - hostElementRect.width) / 2;\n        }\n        return { left, width };\n    }\n    /**\n     * Get position and size of height\n     */\n    getHeightProportions(boundaryRect, hostElementRect, type, width) {\n        let height = this.fromWidthProportion(width);\n        if (!height) {\n            return null;\n        }\n        if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\n            height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\n        }\n        if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\n            height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\n        }\n        let top = hostElementRect.top;\n        if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\n            top = top - (height - hostElementRect.height);\n        }\n        if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\n            top = top - (height - hostElementRect.height) / 2;\n        }\n        return { top, height };\n    }\n    /**\n     * Get width based on {@link ngxResizeAspectRatio} from height\n     */\n    fromHeightProportion(height) {\n        return !this.ngxResizeAspectRatio ? 0 : Math.floor((height / this.ngxResizeAspectRatio) * 100);\n    }\n    /**\n     * Get height based on {@link ngxResizeAspectRatio} from width\n     */\n    fromWidthProportion(width) {\n        return !this.ngxResizeAspectRatio ? 0 : Math.floor((width * this.ngxResizeAspectRatio) / 100);\n    }\n    /**\n     * Updates host element style\n     */\n    updateHostStyle(style, value) {\n        this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Resolves the type of handle HTML element\n     */\n    resolveInitiatorType(initiator) {\n        return initiator.getAttribute('data-ngx-resize-handle-type');\n    }\n    /**\n     * Emits resize event to the {@link ngxResized}\n     */\n    emitResize(nativeEvent) {\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.ngxResized.emit({\n            nativeEvent,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            left: rect.left,\n        });\n    }\n    static ɵfac = function NgxResizeDirective_Factory(t) { return new (t || NgxResizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxResizeDirective, selectors: [[\"\", \"ngxResize\", \"\"]], hostVars: 2, hostBindings: function NgxResizeDirective_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵstyleProp(\"position\", ctx.ngxResizePosition);\n        } }, inputs: { ngxResizeMinWidth: \"ngxResizeMinWidth\", ngxResizeMinHeight: \"ngxResizeMinHeight\", ngxResizeAspectRatio: \"ngxResizeAspectRatio\", ngxResizeDisabled: \"ngxResizeDisabled\", ngxResizeLockAxis: \"ngxResizeLockAxis\", ngxResizeBoundary: \"ngxResizeBoundary\", ngxResizeWheelInitiatorRegExp: \"ngxResizeWheelInitiatorRegExp\", ngxResizeWheelDisabled: \"ngxResizeWheelDisabled\", ngxResizeWheelInverse: \"ngxResizeWheelInverse\", ngxResizeTouchesDisabled: \"ngxResizeTouchesDisabled\", ngxResizePosition: \"ngxResizePosition\" }, outputs: { ngxResized: \"ngxResized\" }, features: [i0.ɵɵInheritDefinitionFeature] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxResize]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragService }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ngxResizeMinWidth: [{\n            type: Input\n        }], ngxResizeMinHeight: [{\n            type: Input\n        }], ngxResizeAspectRatio: [{\n            type: Input\n        }], ngxResizeDisabled: [{\n            type: Input\n        }], ngxResizeLockAxis: [{\n            type: Input\n        }], ngxResizeBoundary: [{\n            type: Input\n        }], ngxResizeWheelInitiatorRegExp: [{\n            type: Input\n        }], ngxResizeWheelDisabled: [{\n            type: Input\n        }], ngxResizeWheelInverse: [{\n            type: Input\n        }], ngxResizeTouchesDisabled: [{\n            type: Input\n        }], ngxResizePosition: [{\n            type: HostBinding,\n            args: ['style.position']\n        }, {\n            type: Input\n        }], ngxResized: [{\n            type: Output\n        }] }); })();","originalLength":89792,"removedExports":[],"renderedExports":["NgxResizeDirective"],"renderedLength":26387},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize-handle.directive.mjs":{"code":"/**\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeHandleDirective {\n    elementRef;\n    platformId;\n    resizeDirective;\n    /**\n     * Sets the attribute which define the side the HTML element will affect during drag\n     */\n    type = null;\n    constructor(elementRef, platformId, resizeDirective) {\n        this.elementRef = elementRef;\n        this.platformId = platformId;\n        this.resizeDirective = resizeDirective;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        if (isPlatformServer(this.platformId) || !this.resizeDirective) {\n            return;\n        }\n        this.resizeDirective.observe(this.elementRef.nativeElement);\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        if (!this.resizeDirective) {\n            return;\n        }\n        this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\n    }\n    static ɵfac = function NgxResizeHandleDirective_Factory(t) { return new (t || NgxResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(NgxResizeDirective, 8)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxResizeHandleDirective, selectors: [[\"\", \"ngxResizeHandle\", \"\"]], hostVars: 1, hostBindings: function NgxResizeHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵattribute(\"data-ngx-resize-handle-type\", ctx.type);\n        } }, inputs: { type: [\"ngxResizeHandle\", \"type\"] } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeHandleDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxResizeHandle]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }, { type: NgxResizeDirective, decorators: [{\n                type: Optional\n            }] }]; }, { type: [{\n            type: Input,\n            args: ['ngxResizeHandle']\n        }, {\n            type: HostBinding,\n            args: ['attr.data-ngx-resize-handle-type']\n        }] }); })();","originalLength":6363,"removedExports":[],"renderedExports":["NgxResizeHandleDirective"],"renderedLength":2387},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/shared/shared.module.mjs":{"code":"/**\n * @internal\n */\nclass SharedModule {\n    static ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: SharedModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SharedModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    BoundaryDirective\n                ],\n                exports: [\n                    BoundaryDirective\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(SharedModule, { declarations: [BoundaryDirective], exports: [BoundaryDirective] }); })();","originalLength":2026,"removedExports":[],"renderedExports":["SharedModule"],"renderedLength":804},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag-resize.module.mjs":{"code":"/**\n * The module provides opportunity to use drag and resize functionality on HTML elements\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n */\nclass NgxDragResizeModule {\n    static ɵfac = function NgxDragResizeModule_Factory(t) { return new (t || NgxDragResizeModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgxDragResizeModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [SharedModule] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragResizeModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    SharedModule\n                ],\n                declarations: [\n                    NgxDragDirective,\n                    NgxDragHandleDirective,\n                    NgxResizeDirective,\n                    NgxResizeHandleDirective\n                ],\n                exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxDragResizeModule, { declarations: [NgxDragDirective,\n        NgxDragHandleDirective,\n        NgxResizeDirective,\n        NgxResizeHandleDirective], imports: [SharedModule], exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective] }); })();","originalLength":4224,"removedExports":[],"renderedExports":["NgxDragResizeModule"],"renderedLength":1433},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/drag/drag.mjs":{"code":"","originalLength":457,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/lib/resize/resize.mjs":{"code":"","originalLength":469,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of ngx-drag-resize\n */","originalLength":1498,"removedExports":[],"renderedExports":[],"renderedLength":47},"/Users/sooyewguan/Desktop/ngx-drag-resize/dist/ngx-drag-resize/esm2022/ngx-drag-resize.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":516,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Injectable, Inject, EventEmitter, PLATFORM_ID, Input, Output, Optional, HostBinding, NgModule } from '@angular/core';\nimport { merge, fromEvent, EMPTY, Subject } from 'rxjs';\nimport { tap, map, switchMap, takeUntil, filter } from 'rxjs/operators';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\n\n/**\n * The directive is used to work with boundary area for HTML element\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass BoundaryDirective {\n    windowObject;\n    documentObject;\n    /**\n     * CSS selector or HTML element\n     */\n    boundary = null;\n    constructor(windowObject, documentObject) {\n        this.windowObject = windowObject;\n        this.documentObject = documentObject;\n    }\n    /**\n     * Get boundary position based on {@link boundary}\n     */\n    getBoundary() {\n        const rect = {};\n        const boundaryElement = this.resolveBoundaryElement();\n        if (boundaryElement instanceof Element) {\n            const boundaryElementRect = boundaryElement.getBoundingClientRect();\n            rect.left = boundaryElementRect.left;\n            rect.top = boundaryElementRect.top;\n            rect.bottom = boundaryElementRect.bottom;\n            rect.right = boundaryElementRect.right;\n            return rect;\n        }\n        if (boundaryElement instanceof Window && this.windowObject) {\n            rect.top = 0;\n            rect.left = 0;\n            rect.right = this.windowObject.innerWidth;\n            rect.bottom = this.windowObject.innerHeight;\n            return rect;\n        }\n        return null;\n    }\n    /**\n     * Resolves HTML element based on {@link boundary}\n     */\n    resolveBoundaryElement() {\n        if (!this.boundary) {\n            return null;\n        }\n        if (this.boundary === 'window' && this.windowObject) {\n            return this.windowObject;\n        }\n        if (typeof this.boundary === 'string') {\n            return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\n        }\n        return this.boundary;\n    }\n    /**\n     * Returns positional value based on boundary position\n     */\n    basedOnBoundary(value, position) {\n        const boundary = this.getBoundary();\n        if (!boundary) {\n            return value;\n        }\n        switch (position) {\n            case 'left':\n                return value - boundary.left;\n            case 'top':\n                return value - boundary.top;\n        }\n        return value;\n    }\n    static ɵfac = function BoundaryDirective_Factory(t) { return new (t || BoundaryDirective)(i0.ɵɵdirectiveInject(Window), i0.ɵɵdirectiveInject(Document)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: BoundaryDirective, selectors: [[\"\", \"ngxBoundary\", \"\"]] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BoundaryDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxBoundary]',\n            }]\n    }], function () { return [{ type: Window }, { type: Document }]; }, null); })();\n\n/**\n * A DI Token representing the window object.\n *\n * Note: might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\n *\n * @internal\n */\nconst WINDOW = new InjectionToken('lib.window', {\n    factory: () => (typeof window !== 'undefined' ? window : null)\n});\n\n/**\n * The service that allows to observe the element dragging\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass DragService {\n    document;\n    window;\n    /**\n     * Emits on mouse or touch event was ended\n     */\n    leave$ = merge(\n    // fromEvent<MovementNative>(this.document, 'mouseup'),\n    // fromEvent<MovementNative>(this.document, 'touchend')\n    );\n    /**\n     * Emits on mouse or touch move\n     */\n    move$ = merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove'));\n    constructor(document, window) {\n        this.document = document;\n        this.window = window;\n    }\n    /**\n     * Creates an observable that emits drag event\n     */\n    fromElement(target) {\n        if (!this.document) {\n            return EMPTY;\n        }\n        const enter$ = merge(fromEvent(target, 'mousedown'), fromEvent(target, 'touchstart'));\n        return enter$.pipe(tap((event) => event.preventDefault()), map((event) => this.fromEnter(event)), switchMap((event) => this.forMove(event)));\n    }\n    /**\n     * Returns position of mouse or touch event\n     */\n    fromMovementNativeEvent(event) {\n        let x = 0;\n        let y = 0;\n        if (!this.window) {\n            return { x, y };\n        }\n        if ('TouchEvent' in this.window && event instanceof TouchEvent) {\n            const touch = event.touches.length ? event.touches.item(0) : null;\n            x = touch ? touch.clientX : 0;\n            y = touch ? touch.clientY : 0;\n        }\n        if (event instanceof MouseEvent) {\n            x = event.clientX;\n            y = event.clientY;\n        }\n        return { x, y };\n    }\n    /**\n     * Returns position of event when drag was started\n     */\n    fromEnter(event) {\n        return this.fromMovementNativeEvent(event);\n    }\n    /**\n     * Implements behaviour to detect drag events\n     */\n    forMove(initial) {\n        return this.move$.pipe(map((event) => {\n            const positionBase = this.fromMovementNativeEvent(event);\n            return {\n                ...positionBase,\n                initial,\n                nativeEvent: event,\n            };\n        }), takeUntil(this.leave$));\n    }\n    static ɵfac = function DragService_Factory(t) { return new (t || DragService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(WINDOW)); };\n    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DragService, factory: DragService.ɵfac, providedIn: 'root' });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root',\n            }]\n    }], function () { return [{ type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }]; }, null); })();\n\n/**\n * The directive that allows to drag HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragDirective extends BoundaryDirective {\n    elementRef;\n    renderer;\n    dragService;\n    window;\n    document;\n    platformId;\n    /**\n     * Initial size and position of host element\n     */\n    hostElementRectInitial = null;\n    /**\n     * Emits when directive was destroyed\n     */\n    destroy$ = new Subject();\n    /**\n     * Emits when observable target was changed\n     */\n    observableTargetChange$ = new Subject();\n    /**\n     * Define positioning strategy.\n     *\n     * 'free' - position will changing by 'transform: translate3d()' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n     *\n     * 'relative' - position will changing by 'top' and 'left' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     *\n     * Default is 'free'.\n     */\n    ngxDragPositionStrategy = 'free';\n    /**\n     * Locks axis for the dragging\n     */\n    ngxDragLockAxis = null;\n    /**\n     * Disable any drag events\n     */\n    ngxDragDisabled = false;\n    /**\n     * Constrain for the dragging element.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxDragBoundary(boundary) {\n        this.boundary = boundary;\n    }\n    /**\n     * Emits changes when element was dragged\n     */\n    ngxDragged = new EventEmitter();\n    constructor(elementRef, renderer, dragService, window, document, platformId) {\n        console.log('[DragDirective] constructed', window, document);\n        super(window, document);\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.dragService = dragService;\n        this.window = window;\n        this.document = document;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnInit() {\n        if (isPlatformServer(this.platformId)) {\n            return;\n        }\n        this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.destroy$.next(true);\n        this.destroy$.complete();\n        this.observableTargetChange$.complete();\n    }\n    /**\n     * Observe the element dragging which will be as handle for dragging\n     */\n    observe(target = this.elementRef.nativeElement) {\n        this.observableTargetChange$.next(true);\n        let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        let eventInitial = null;\n        this.dragService\n            .fromElement(target)\n            .pipe(tap((event) => event.nativeEvent.preventDefault()), map((event) => {\n            if (!eventInitial ||\n                eventInitial.x !== event.initial.x ||\n                eventInitial.y !== event.initial.y) {\n                eventInitial = event.initial;\n                hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n                if (!this.hostElementRectInitial) {\n                    this.updateInitialRect();\n                }\n            }\n            const offsetFromHost = {\n                top: event.initial.y - hostElementRect.top,\n                left: event.initial.x - hostElementRect.left,\n                bottom: hostElementRect.bottom - event.initial.y,\n                right: hostElementRect.right - event.initial.x,\n            };\n            return {\n                ...event,\n                initiator: target,\n                offsetFromHost,\n                initial: event.initial,\n            };\n        }), tap(this.onDrag.bind(this)), takeUntil(this.destroy$), takeUntil(this.observableTargetChange$))\n            .subscribe();\n    }\n    /**\n     * Update size and position of host element\n     */\n    updateInitialRect() {\n        if (!this.window) {\n            return;\n        }\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.hostElementRectInitial = {\n            left: this.window.scrollX + rect.left,\n            top: this.window.scrollY + rect.top,\n        };\n    }\n    /**\n     * Starts the calculation of drag event and changes host position\n     */\n    onDrag(event) {\n        if (this.ngxDragDisabled) {\n            return;\n        }\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        let left = event.x - event.offsetFromHost.left;\n        let top = event.y - event.offsetFromHost.top;\n        if (boundaryRect) {\n            left = Math.max(boundaryRect.left, left);\n            left = Math.min(boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width, left);\n            top = Math.max(boundaryRect.top, top);\n            top = Math.min(boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height, top);\n        }\n        if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\n            left = left - this.hostElementRectInitial.left + this.window.scrollX;\n            top = top - this.hostElementRectInitial.top + this.window.scrollY;\n            if (this.ngxDragLockAxis === 'y') {\n                top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\n            }\n            if (this.ngxDragLockAxis === 'x') {\n                left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\n            }\n            this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        if (this.ngxDragLockAxis === 'x') {\n            this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        if (this.ngxDragLockAxis === 'y') {\n            this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n            this.emitDrag(event.nativeEvent);\n            return;\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.emitDrag(event.nativeEvent);\n    }\n    /**\n     * Updates the host style\n     */\n    updateHostStyle(style, value) {\n        this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Emits drag event to the {@link ngxDragged}\n     */\n    emitDrag(nativeEvent) {\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.ngxDragged.emit({\n            nativeEvent,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            left: rect.left,\n        });\n    }\n    static ɵfac = function NgxDragDirective_Factory(t) { return new (t || NgxDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxDragDirective, selectors: [[\"\", \"ngxDrag\", \"\"]], inputs: { ngxDragPositionStrategy: \"ngxDragPositionStrategy\", ngxDragLockAxis: \"ngxDragLockAxis\", ngxDragDisabled: \"ngxDragDisabled\", ngxDragBoundary: \"ngxDragBoundary\" }, outputs: { ngxDragged: \"ngxDragged\" }, features: [i0.ɵɵInheritDefinitionFeature] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxDrag]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragService }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ngxDragPositionStrategy: [{\n            type: Input\n        }], ngxDragLockAxis: [{\n            type: Input\n        }], ngxDragDisabled: [{\n            type: Input\n        }], ngxDragBoundary: [{\n            type: Input\n        }], ngxDragged: [{\n            type: Output\n        }] }); })();\n\n/**\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragHandleDirective {\n    elementRef;\n    dragDirective;\n    platformId;\n    constructor(elementRef, dragDirective, platformId) {\n        this.elementRef = elementRef;\n        this.dragDirective = dragDirective;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        this.observe();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.observe();\n    }\n    /**\n     * Sets host element as observable point for {@link NgxDragDirective}\n     */\n    observe() {\n        if (isPlatformServer(this.platformId) || !this.dragDirective) {\n            return;\n        }\n        this.dragDirective.observe(this.elementRef.nativeElement);\n    }\n    static ɵfac = function NgxDragHandleDirective_Factory(t) { return new (t || NgxDragHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxDragDirective, 8), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxDragHandleDirective, selectors: [[\"\", \"ngxDragHandle\", \"\"]] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragHandleDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxDragHandle]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: NgxDragDirective, decorators: [{\n                type: Optional\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\n\nvar NgxResizeHandleType;\n(function (NgxResizeHandleType) {\n    NgxResizeHandleType[\"TopLeft\"] = \"top-left\";\n    NgxResizeHandleType[\"Top\"] = \"top\";\n    NgxResizeHandleType[\"TopRight\"] = \"top-right\";\n    NgxResizeHandleType[\"Right\"] = \"right\";\n    NgxResizeHandleType[\"BottomRight\"] = \"bottom-right\";\n    NgxResizeHandleType[\"Bottom\"] = \"bottom\";\n    NgxResizeHandleType[\"BottomLeft\"] = \"bottom-left\";\n    NgxResizeHandleType[\"Left\"] = \"left\";\n})(NgxResizeHandleType || (NgxResizeHandleType = {}));\n\n/**\n * The directive that allows to resize HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeDirective extends BoundaryDirective {\n    elementRef;\n    renderer;\n    dragService;\n    document;\n    window;\n    platformId;\n    /**\n     * Emits when directive was destroyed\n     */\n    destroy$ = new Subject();\n    /**\n     * Emits next every time when behaviour for wheel event was changed\n     */\n    wheelBehaviourChange$ = new Subject();\n    /**\n     * Emits next every time when behaviour for touches event was changed\n     */\n    touchBehaviourChange$ = new Subject();\n    /**\n     * An array of observers which affect on resizable element\n     */\n    observers = [];\n    /**\n     * A regular expression for keyboard code\n     */\n    wheelInitiatorRegExp = null;\n    /**\n     * Make a resize unavailable by wheel\n     */\n    isWheelDisabled = false;\n    /**\n     * Make a resize unavailable by touches\n     */\n    isTouchesDisabled = false;\n    /**\n     * Minimal width in px\n     */\n    ngxResizeMinWidth = 0;\n    /**\n     * Minimal height in px\n     */\n    ngxResizeMinHeight = 0;\n    /**\n     * Aspect ratio the element will use during resize\n     *\n     * @example\n     * 16/9 - 9/16 * 100 = 56.25\n     * 1/1 - 1/1 * 100 = 100\n     */\n    ngxResizeAspectRatio = 0;\n    /**\n     * Disables any resize events\n     */\n    ngxResizeDisabled = false;\n    /**\n     * Locks axis for the resize\n     */\n    ngxResizeLockAxis = null;\n    /**\n     * Constrain of the resizing area.\n     * Can be as a HTMLElement or CSS selector.\n     * You can put 'window' string to define window object as a constrain.\n     */\n    set ngxResizeBoundary(boundary) {\n        this.boundary = boundary;\n    }\n    /**\n     * A regular expression that matches with keyboard key code.\n     * When value is provided the element can be scaled by 'Key + wheel'.\n     * If value not provided the element can be scaled just by 'wheel'.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n     */\n    set ngxResizeWheelInitiatorRegExp(pattern) {\n        if (!pattern) {\n            this.wheelInitiatorRegExp = null;\n            this.subscribeForWheelEvent();\n            return;\n        }\n        this.wheelInitiatorRegExp = new RegExp(pattern);\n        this.subscribeForWheelEvent();\n    }\n    /**\n     * Disables resize by wheel.\n     * By default is 'false'.\n     */\n    set ngxResizeWheelDisabled(disabled) {\n        this.isWheelDisabled = disabled;\n        this.subscribeForWheelEvent();\n    }\n    /**\n     * Enables inversion for wheel event\n     */\n    ngxResizeWheelInverse = false;\n    /**\n     * Disables resize by touches.\n     * By default is 'false'.\n     * Resize work by using two fingers.\n     */\n    set ngxResizeTouchesDisabled(disabled) {\n        this.isTouchesDisabled = disabled;\n        this.subscribeForTouchEvents();\n    }\n    /**\n     * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\n     * Will be applied to host element.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     */\n    ngxResizePosition = 'absolute';\n    /**\n     * Emits changes when element was resized\n     */\n    ngxResized = new EventEmitter();\n    constructor(elementRef, renderer, dragService, document, window, platformId) {\n        super(window, document);\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.dragService = dragService;\n        this.document = document;\n        this.window = window;\n        this.platformId = platformId;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        if (isPlatformServer(this.platformId)) {\n            return;\n        }\n        this.initialResize();\n        this.subscribeForWheelEvent();\n        this.subscribeForTouchEvents();\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        this.destroy$.next(true);\n        this.destroy$.complete();\n        this.wheelBehaviourChange$.complete();\n        this.touchBehaviourChange$.complete();\n    }\n    /**\n     * Unsubscribe from the element dragging and remove it from an array of observable objects\n     */\n    unsubscribe(target) {\n        const indexOf = this.observers.findIndex((item) => item.element === target);\n        if (indexOf < 0) {\n            return;\n        }\n        this.observers[indexOf].subscription.unsubscribe();\n        this.observers.splice(indexOf, 1);\n    }\n    /**\n     * Observe the element dragging which will be as handle for resize\n     */\n    observe(target) {\n        if (!this.resolveInitiatorType(target)) {\n            return;\n        }\n        let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        let eventInitial = null;\n        const subscription$ = this.dragService\n            .fromElement(target)\n            .pipe(tap((event) => event.nativeEvent.preventDefault()), tap((event) => event.nativeEvent.stopImmediatePropagation()), map((event) => {\n            if (!eventInitial ||\n                eventInitial.x !== event.initial.x ||\n                eventInitial.y !== event.initial.y) {\n                eventInitial = event.initial;\n                hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n            }\n            const offsetFromHost = {\n                top: event.initial.y - hostElementRect.top,\n                left: event.initial.x - hostElementRect.left,\n                bottom: hostElementRect.bottom - event.initial.y,\n                right: hostElementRect.right - event.initial.x,\n            };\n            return {\n                ...event,\n                initiator: target,\n                offsetFromHost,\n                initial: event.initial,\n                nativeEvent: event.nativeEvent,\n            };\n        }), tap(this.onResize.bind(this)), takeUntil(this.destroy$))\n            .subscribe();\n        this.observers.push({ subscription: subscription$, element: target });\n    }\n    /**\n     * Starts the subscription for touch events\n     */\n    subscribeForTouchEvents() {\n        this.touchBehaviourChange$.next(true);\n        if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\n            return;\n        }\n        let prevDistance = 0;\n        const touchStart$ = fromEvent(this.elementRef.nativeElement, 'touchstart').pipe(filter((event) => event.targetTouches.length === 2));\n        const touchEnd$ = fromEvent(this.elementRef.nativeElement, 'touchend');\n        const touchMove$ = fromEvent(this.elementRef.nativeElement, 'touchmove', {\n            passive: false,\n        }).pipe(tap((event) => event.preventDefault()), filter((event) => event.targetTouches.length === 2 && event.changedTouches.length === 2));\n        touchStart$\n            .pipe(tap((event) => {\n            const aTouch = event.targetTouches.item(0);\n            const bTouch = event.targetTouches.item(1);\n            if (!aTouch || !bTouch) {\n                return;\n            }\n            prevDistance = this.touchesDistance(aTouch, bTouch);\n        }), switchMap(() => touchMove$.pipe(tap((event) => {\n            const aTouch = event.targetTouches.item(0);\n            const bTouch = event.targetTouches.item(1);\n            if (!aTouch || !bTouch) {\n                return;\n            }\n            const distance = this.touchesDistance(aTouch, bTouch);\n            this.onScale({ delta: distance - prevDistance }, event);\n            prevDistance = distance;\n        }), takeUntil(touchEnd$))), takeUntil(this.destroy$), takeUntil(this.touchBehaviourChange$))\n            .subscribe();\n    }\n    /**\n     * Returns distance between two touches\n     */\n    touchesDistance(a, b) {\n        return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\n    }\n    /**\n     * Make a subscription for wheel events\n     */\n    subscribeForWheelEvent() {\n        this.wheelBehaviourChange$.next(true);\n        if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\n            return;\n        }\n        const wheel$ = fromEvent(this.elementRef.nativeElement, 'wheel').pipe(tap((event) => event.preventDefault()), tap((event) => {\n            const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\n            this.onScale({ delta }, event);\n        }), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$));\n        if (!this.wheelInitiatorRegExp) {\n            wheel$.subscribe();\n            return;\n        }\n        const wheelInitiatorFilter = filter((event) => this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\n        const wheelInitiatorStart$ = fromEvent(this.window, 'keydown').pipe(wheelInitiatorFilter);\n        const wheelInitiatorEnd$ = fromEvent(this.window, 'keyup').pipe(wheelInitiatorFilter);\n        wheelInitiatorStart$\n            .pipe(switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$))\n            .subscribe();\n    }\n    /**\n     * Runs initial resize for the host element\n     */\n    initialResize() {\n        setTimeout(() => {\n            this.onScale({ delta: 0 });\n        });\n    }\n    /**\n     * Starts the calculation of scale event and changes host size\n     */\n    onScale(scale, nativeEvent) {\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        let maxUpscale = scale.delta;\n        if (boundaryRect) {\n            maxUpscale = Math.floor(Math.min(hostElementRect.top - boundaryRect.top, boundaryRect.right - hostElementRect.right, boundaryRect.bottom - hostElementRect.bottom, hostElementRect.left - boundaryRect.left));\n        }\n        const maxDownscale = Math.max(0, Math.min(hostElementRect.width - this.ngxResizeMinWidth, hostElementRect.height - this.ngxResizeMinHeight)) * -1;\n        const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\n        let top = hostElementRect.top - delta / 2;\n        let left = hostElementRect.left - delta / 2;\n        if (boundaryRect) {\n            top = Math.max(boundaryRect.top, top);\n            left = Math.max(boundaryRect.left, left);\n        }\n        let height = hostElementRect.height + delta;\n        let width = hostElementRect.width + delta;\n        if (boundaryRect) {\n            height = Math.min(boundaryRect.bottom - top, height);\n            width = Math.min(boundaryRect.right - left, width);\n        }\n        if (this.ngxResizeLockAxis === 'x') {\n            left = hostElementRect.left;\n            width = hostElementRect.width;\n        }\n        if (this.ngxResizeLockAxis === 'y') {\n            top = hostElementRect.top;\n            height = hostElementRect.height;\n        }\n        const proportionalSize = this.ngxResizeLockAxis === 'y'\n            ? this.fromWidthProportion(width)\n            : this.fromHeightProportion(height);\n        if (proportionalSize && this.ngxResizeLockAxis === 'y') {\n            height = proportionalSize;\n            top = hostElementRect.top - (height - hostElementRect.height) / 2;\n        }\n        if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\n            width = proportionalSize;\n            left = hostElementRect.left - (width - hostElementRect.width) / 2;\n        }\n        if (boundaryRect &&\n            (top <= boundaryRect.top ||\n                top + height >= boundaryRect.bottom ||\n                left <= boundaryRect.left ||\n                left + width >= boundaryRect.right)) {\n            top = hostElementRect.top;\n            height = hostElementRect.height;\n            left = hostElementRect.left;\n            width = hostElementRect.width;\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('width', `${width}px`);\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.updateHostStyle('height', `${height}px`);\n        this.emitResize(nativeEvent);\n    }\n    /**\n     * Check whether is resize is available for current initiator type\n     */\n    canResize(initiatorType) {\n        switch (initiatorType) {\n            case NgxResizeHandleType.TopLeft:\n            case NgxResizeHandleType.TopRight:\n            case NgxResizeHandleType.BottomLeft:\n            case NgxResizeHandleType.BottomRight:\n                return !this.ngxResizeLockAxis;\n            case NgxResizeHandleType.Left:\n            case NgxResizeHandleType.Right:\n                return this.ngxResizeLockAxis !== 'x';\n            case NgxResizeHandleType.Top:\n            case NgxResizeHandleType.Bottom:\n                return this.ngxResizeLockAxis !== 'y';\n        }\n        return !this.ngxResizeLockAxis;\n    }\n    /**\n     * Starts the calculation of resize event and changes host size\n     */\n    onResize(event) {\n        if (this.ngxResizeDisabled) {\n            return;\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        if (!initiatorType || !this.canResize(initiatorType)) {\n            return;\n        }\n        const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        const boundaryRect = this.getBoundary();\n        if (!boundaryRect) {\n            return;\n        }\n        switch (initiatorType) {\n            case NgxResizeHandleType.TopLeft:\n                return this.topLeftMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Top:\n                return this.topMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.TopRight:\n                return this.topRightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Right:\n                return this.rightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.BottomRight:\n                return this.bottomRightMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Bottom:\n                return this.bottomMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.BottomLeft:\n                return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\n            case NgxResizeHandleType.Left:\n                return this.leftMovement(event, hostElementRect, boundaryRect);\n        }\n    }\n    topLeftMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.topMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.topMovement(event, hostElementRect, boundaryRect);\n        this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topRightMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.topMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.topMovement(event, hostElementRect, boundaryRect);\n        this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomRightMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.bottomMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        this.rightMovement(event, hostElementRect, boundaryRect);\n    }\n    bottomLeftMovement(event, hostElementRect, boundaryRect) {\n        if (this.ngxResizeAspectRatio) {\n            this.bottomMovement(event, hostElementRect, boundaryRect);\n            return;\n        }\n        this.bottomMovement(event, hostElementRect, boundaryRect);\n        this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n    topMovement(event, hostElementRect, boundaryRect) {\n        let y = event.y - event.offsetFromHost.top;\n        if (boundaryRect) {\n            y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n        }\n        let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\n        let height = hostElementRect.height - (top - hostElementRect.top);\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n        if (widthProportions) {\n            top = top + (height - this.fromWidthProportion(widthProportions.width));\n            height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n        }\n        this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n        this.updateHostStyle('height', `${height}px`);\n        if (widthProportions) {\n            this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n            this.updateHostStyle('width', `${widthProportions.width}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    rightMovement(event, hostElementRect, boundaryRect) {\n        let x = event.x + event.offsetFromHost.right;\n        if (boundaryRect) {\n            x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n        }\n        let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\n        if (boundaryRect) {\n            width = Math.min(width, boundaryRect.right - hostElementRect.left);\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n        if (heightProportions) {\n            width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n        }\n        this.updateHostStyle('width', `${width}px`);\n        if (heightProportions) {\n            this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n            this.updateHostStyle('height', `${heightProportions.height}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    bottomMovement(event, hostElementRect, boundaryRect) {\n        let y = event.y + event.offsetFromHost.bottom;\n        if (boundaryRect) {\n            y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n        }\n        let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\n        if (boundaryRect) {\n            height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\n        }\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n        if (widthProportions) {\n            height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n        }\n        this.updateHostStyle('height', `${height}px`);\n        if (widthProportions) {\n            this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n            this.updateHostStyle('width', `${widthProportions.width}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    leftMovement(event, hostElementRect, boundaryRect) {\n        let x = event.x - event.offsetFromHost.left;\n        if (boundaryRect) {\n            x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n        }\n        let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\n        let width = hostElementRect.width - (left - hostElementRect.left);\n        const initiatorType = this.resolveInitiatorType(event.initiator);\n        const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n        if (heightProportions) {\n            left = left + (width - this.fromHeightProportion(heightProportions.height));\n            width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n        }\n        this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n        this.updateHostStyle('width', `${width}px`);\n        if (heightProportions) {\n            this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n            this.updateHostStyle('height', `${heightProportions.height}px`);\n        }\n        this.emitResize(event.nativeEvent);\n    }\n    /**\n     * Get position and size of width\n     */\n    getWidthProportions(boundaryRect, hostElementRect, type, height) {\n        let width = this.fromHeightProportion(height);\n        if (!width) {\n            return null;\n        }\n        if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\n            width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\n        }\n        if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\n            width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\n        }\n        let left = hostElementRect.left;\n        if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\n            left = left - (width - hostElementRect.width);\n        }\n        if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\n            left = left - (width - hostElementRect.width) / 2;\n        }\n        return { left, width };\n    }\n    /**\n     * Get position and size of height\n     */\n    getHeightProportions(boundaryRect, hostElementRect, type, width) {\n        let height = this.fromWidthProportion(width);\n        if (!height) {\n            return null;\n        }\n        if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\n            height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\n        }\n        if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\n            height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\n        }\n        let top = hostElementRect.top;\n        if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\n            top = top - (height - hostElementRect.height);\n        }\n        if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\n            top = top - (height - hostElementRect.height) / 2;\n        }\n        return { top, height };\n    }\n    /**\n     * Get width based on {@link ngxResizeAspectRatio} from height\n     */\n    fromHeightProportion(height) {\n        return !this.ngxResizeAspectRatio ? 0 : Math.floor((height / this.ngxResizeAspectRatio) * 100);\n    }\n    /**\n     * Get height based on {@link ngxResizeAspectRatio} from width\n     */\n    fromWidthProportion(width) {\n        return !this.ngxResizeAspectRatio ? 0 : Math.floor((width * this.ngxResizeAspectRatio) / 100);\n    }\n    /**\n     * Updates host element style\n     */\n    updateHostStyle(style, value) {\n        this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n    }\n    /**\n     * Resolves the type of handle HTML element\n     */\n    resolveInitiatorType(initiator) {\n        return initiator.getAttribute('data-ngx-resize-handle-type');\n    }\n    /**\n     * Emits resize event to the {@link ngxResized}\n     */\n    emitResize(nativeEvent) {\n        const rect = this.elementRef.nativeElement.getBoundingClientRect();\n        this.ngxResized.emit({\n            nativeEvent,\n            top: rect.top,\n            right: rect.right,\n            bottom: rect.bottom,\n            left: rect.left,\n        });\n    }\n    static ɵfac = function NgxResizeDirective_Factory(t) { return new (t || NgxResizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(PLATFORM_ID)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxResizeDirective, selectors: [[\"\", \"ngxResize\", \"\"]], hostVars: 2, hostBindings: function NgxResizeDirective_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵstyleProp(\"position\", ctx.ngxResizePosition);\n        } }, inputs: { ngxResizeMinWidth: \"ngxResizeMinWidth\", ngxResizeMinHeight: \"ngxResizeMinHeight\", ngxResizeAspectRatio: \"ngxResizeAspectRatio\", ngxResizeDisabled: \"ngxResizeDisabled\", ngxResizeLockAxis: \"ngxResizeLockAxis\", ngxResizeBoundary: \"ngxResizeBoundary\", ngxResizeWheelInitiatorRegExp: \"ngxResizeWheelInitiatorRegExp\", ngxResizeWheelDisabled: \"ngxResizeWheelDisabled\", ngxResizeWheelInverse: \"ngxResizeWheelInverse\", ngxResizeTouchesDisabled: \"ngxResizeTouchesDisabled\", ngxResizePosition: \"ngxResizePosition\" }, outputs: { ngxResized: \"ngxResized\" }, features: [i0.ɵɵInheritDefinitionFeature] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxResize]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DragService }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }, { type: Window, decorators: [{\n                type: Inject,\n                args: [WINDOW]\n            }] }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, { ngxResizeMinWidth: [{\n            type: Input\n        }], ngxResizeMinHeight: [{\n            type: Input\n        }], ngxResizeAspectRatio: [{\n            type: Input\n        }], ngxResizeDisabled: [{\n            type: Input\n        }], ngxResizeLockAxis: [{\n            type: Input\n        }], ngxResizeBoundary: [{\n            type: Input\n        }], ngxResizeWheelInitiatorRegExp: [{\n            type: Input\n        }], ngxResizeWheelDisabled: [{\n            type: Input\n        }], ngxResizeWheelInverse: [{\n            type: Input\n        }], ngxResizeTouchesDisabled: [{\n            type: Input\n        }], ngxResizePosition: [{\n            type: HostBinding,\n            args: ['style.position']\n        }, {\n            type: Input\n        }], ngxResized: [{\n            type: Output\n        }] }); })();\n\n/**\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeHandleDirective {\n    elementRef;\n    platformId;\n    resizeDirective;\n    /**\n     * Sets the attribute which define the side the HTML element will affect during drag\n     */\n    type = null;\n    constructor(elementRef, platformId, resizeDirective) {\n        this.elementRef = elementRef;\n        this.platformId = platformId;\n        this.resizeDirective = resizeDirective;\n    }\n    /**\n     * @inheritDoc\n     */\n    ngAfterViewInit() {\n        if (isPlatformServer(this.platformId) || !this.resizeDirective) {\n            return;\n        }\n        this.resizeDirective.observe(this.elementRef.nativeElement);\n    }\n    /**\n     * @inheritDoc\n     */\n    ngOnDestroy() {\n        if (!this.resizeDirective) {\n            return;\n        }\n        this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\n    }\n    static ɵfac = function NgxResizeHandleDirective_Factory(t) { return new (t || NgxResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(NgxResizeDirective, 8)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgxResizeHandleDirective, selectors: [[\"\", \"ngxResizeHandle\", \"\"]], hostVars: 1, hostBindings: function NgxResizeHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {\n            i0.ɵɵattribute(\"data-ngx-resize-handle-type\", ctx.type);\n        } }, inputs: { type: [\"ngxResizeHandle\", \"type\"] } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeHandleDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngxResizeHandle]',\n            }]\n    }], function () { return [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }, { type: NgxResizeDirective, decorators: [{\n                type: Optional\n            }] }]; }, { type: [{\n            type: Input,\n            args: ['ngxResizeHandle']\n        }, {\n            type: HostBinding,\n            args: ['attr.data-ngx-resize-handle-type']\n        }] }); })();\n\n/**\n * @internal\n */\nclass SharedModule {\n    static ɵfac = function SharedModule_Factory(t) { return new (t || SharedModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: SharedModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SharedModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    BoundaryDirective\n                ],\n                exports: [\n                    BoundaryDirective\n                ]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(SharedModule, { declarations: [BoundaryDirective], exports: [BoundaryDirective] }); })();\n\n/**\n * The module provides opportunity to use drag and resize functionality on HTML elements\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n */\nclass NgxDragResizeModule {\n    static ɵfac = function NgxDragResizeModule_Factory(t) { return new (t || NgxDragResizeModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgxDragResizeModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [SharedModule] });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragResizeModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    SharedModule\n                ],\n                declarations: [\n                    NgxDragDirective,\n                    NgxDragHandleDirective,\n                    NgxResizeDirective,\n                    NgxResizeHandleDirective\n                ],\n                exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxDragResizeModule, { declarations: [NgxDragDirective,\n        NgxDragHandleDirective,\n        NgxResizeDirective,\n        NgxResizeHandleDirective], imports: [SharedModule], exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective] }); })();\n\n/*\n * Public API Surface of ngx-drag-resize\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxDragDirective, NgxDragHandleDirective, NgxDragResizeModule, NgxResizeDirective, NgxResizeHandleDirective, NgxResizeHandleType };\n//# sourceMappingURL=ngx-drag-resize.mjs.map\n","map":null},{"fileName":"ngx-drag-resize.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ngx-drag-resize.mjs\",\"sources\":[\"../../../projects/ngx-drag-resize/src/lib/shared/boundary/boundary.directive.ts\",\"../../../projects/ngx-drag-resize/src/lib/core/window.token.ts\",\"../../../projects/ngx-drag-resize/src/lib/core/drag.service.ts\",\"../../../projects/ngx-drag-resize/src/lib/drag/drag.directive.ts\",\"../../../projects/ngx-drag-resize/src/lib/drag/drag-handle.directive.ts\",\"../../../projects/ngx-drag-resize/src/lib/resize/resize-handle-type.enum.ts\",\"../../../projects/ngx-drag-resize/src/lib/resize/resize.directive.ts\",\"../../../projects/ngx-drag-resize/src/lib/resize/resize-handle.directive.ts\",\"../../../projects/ngx-drag-resize/src/lib/shared/shared.module.ts\",\"../../../projects/ngx-drag-resize/src/lib/drag-resize.module.ts\",\"../../../projects/ngx-drag-resize/src/public-api.ts\",\"../../../projects/ngx-drag-resize/src/ngx-drag-resize.ts\"],\"sourcesContent\":[\"import {Directive} from '@angular/core';\\nimport {Boundary} from './boundary';\\n\\n/**\\n * The directive is used to work with boundary area for HTML element\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @internal\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Directive({\\n  selector: '[ngxBoundary]',\\n})\\nexport class BoundaryDirective {\\n  /**\\n   * CSS selector or HTML element\\n   */\\n  protected boundary: string | HTMLElement | Window | null = null;\\n\\n  constructor(private readonly windowObject?: Window, private readonly documentObject?: Document) {}\\n\\n  /**\\n   * Get boundary position based on {@link boundary}\\n   */\\n  protected getBoundary(): Boundary | null {\\n    const rect = {} as Boundary;\\n\\n    const boundaryElement = this.resolveBoundaryElement();\\n\\n    if (boundaryElement instanceof Element) {\\n      const boundaryElementRect = boundaryElement.getBoundingClientRect();\\n\\n      rect.left = boundaryElementRect.left;\\n      rect.top = boundaryElementRect.top;\\n      rect.bottom = boundaryElementRect.bottom;\\n      rect.right = boundaryElementRect.right;\\n\\n      return rect;\\n    }\\n\\n    if (boundaryElement instanceof Window && this.windowObject) {\\n      rect.top = 0;\\n      rect.left = 0;\\n      rect.right = this.windowObject.innerWidth;\\n      rect.bottom = this.windowObject.innerHeight;\\n\\n      return rect;\\n    }\\n\\n    return null;\\n  }\\n\\n  /**\\n   * Resolves HTML element based on {@link boundary}\\n   */\\n  protected resolveBoundaryElement(): Element | Window | null {\\n    if (!this.boundary) {\\n      return null;\\n    }\\n\\n    if (this.boundary === 'window' && this.windowObject) {\\n      return this.windowObject;\\n    }\\n\\n    if (typeof this.boundary === 'string') {\\n      return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\\n    }\\n\\n    return this.boundary;\\n  }\\n\\n  /**\\n   * Returns positional value based on boundary position\\n   */\\n  protected basedOnBoundary(value: number, position: 'left' | 'top'): number {\\n    const boundary = this.getBoundary();\\n\\n    if (!boundary) {\\n      return value;\\n    }\\n\\n    switch (position) {\\n      case 'left':\\n        return value - boundary.left;\\n      case 'top':\\n        return value - boundary.top;\\n    }\\n\\n    return value;\\n  }\\n}\\n\",\"import {InjectionToken} from '@angular/core';\\n\\n/**\\n * A DI Token representing the window object.\\n *\\n * Note: might not be available in the Application Context when Application and Rendering\\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\\n *\\n * @internal\\n */\\nexport const WINDOW = new InjectionToken<Window | null>('lib.window', {\\n  factory: () => (typeof window !== 'undefined' ? window : null)\\n});\\n\",\"import {Inject, Injectable} from '@angular/core';\\nimport {EMPTY, fromEvent, merge, Observable} from 'rxjs';\\nimport {DOCUMENT} from '@angular/common';\\nimport {map, switchMap, takeUntil, tap} from 'rxjs/operators';\\nimport {MovementNative} from './movement/movement-native';\\nimport {PositionBase} from './position-base';\\nimport {MovementBase} from './movement/movement-base';\\nimport {WINDOW} from './window.token';\\n\\n/**\\n * The service that allows to observe the element dragging\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @internal\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Injectable({\\n  providedIn: 'root',\\n})\\nexport class DragService {\\n  /**\\n   * Emits on mouse or touch event was ended\\n   */\\n  private readonly leave$ = merge(\\n    // fromEvent<MovementNative>(this.document, 'mouseup'),\\n    // fromEvent<MovementNative>(this.document, 'touchend')\\n  );\\n\\n  /**\\n   * Emits on mouse or touch move\\n   */\\n  private readonly move$ = merge(\\n    fromEvent<MovementNative>(this.document, 'mousemove'),\\n    fromEvent<MovementNative>(this.document, 'touchmove')\\n  );\\n\\n  constructor(\\n    @Inject(DOCUMENT) private readonly document: Document,\\n    @Inject(WINDOW) private readonly window: Window\\n  ) {}\\n\\n  /**\\n   * Creates an observable that emits drag event\\n   */\\n  fromElement(target: HTMLElement): Observable<MovementBase> {\\n    if (!this.document) {\\n      return EMPTY;\\n    }\\n\\n    const enter$ = merge(\\n      fromEvent<MovementNative>(target, 'mousedown'),\\n      fromEvent<MovementNative>(target, 'touchstart')\\n    );\\n\\n    return enter$.pipe(\\n      tap((event) => event.preventDefault()),\\n      map((event) => this.fromEnter(event)),\\n      switchMap((event) => this.forMove(event))\\n    );\\n  }\\n\\n  /**\\n   * Returns position of mouse or touch event\\n   */\\n  private fromMovementNativeEvent(event: MovementNative): PositionBase {\\n    let x = 0;\\n    let y = 0;\\n\\n    if (!this.window) {\\n      return { x, y };\\n    }\\n\\n    if ('TouchEvent' in this.window && event instanceof TouchEvent) {\\n      const touch = event.touches.length ? event.touches.item(0) : null;\\n      x = touch ? touch.clientX : 0;\\n      y = touch ? touch.clientY : 0;\\n    }\\n\\n    if (event instanceof MouseEvent) {\\n      x = event.clientX;\\n      y = event.clientY;\\n    }\\n\\n    return { x, y };\\n  }\\n\\n  /**\\n   * Returns position of event when drag was started\\n   */\\n  private fromEnter(event: MovementNative): PositionBase {\\n    return this.fromMovementNativeEvent(event);\\n  }\\n\\n  /**\\n   * Implements behaviour to detect drag events\\n   */\\n  private forMove(initial: PositionBase): Observable<MovementBase> {\\n    return this.move$.pipe(\\n      map((event) => {\\n        const positionBase = this.fromMovementNativeEvent(event);\\n\\n        return {\\n          ...positionBase,\\n          initial,\\n          nativeEvent: event,\\n        };\\n      }),\\n      takeUntil(this.leave$)\\n    );\\n  }\\n}\\n\",\"import {\\n  Directive,\\n  ElementRef,\\n  EventEmitter,\\n  Inject,\\n  Input,\\n  OnDestroy,\\n  OnInit,\\n  Output,\\n  PLATFORM_ID,\\n  Renderer2,\\n} from '@angular/core';\\nimport { Subject } from 'rxjs';\\nimport { map, takeUntil, tap } from 'rxjs/operators';\\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\\nimport {BoundaryDirective} from '../shared/boundary/boundary.directive';\\nimport {PositionStrategy} from './position-strategy';\\nimport {Axis} from '../core/axis';\\nimport {NgxDrag} from './drag';\\nimport {DragService} from '../core/drag.service';\\nimport {WINDOW} from '../core/window.token';\\nimport {MovementBase} from '../core/movement/movement-base';\\nimport {Movement} from '../core/movement/movement';\\nimport {Boundary} from '../shared/boundary/boundary';\\nimport {PositionBase} from '../core/position-base';\\n\\n/**\\n * The directive that allows to drag HTML element on page\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Directive({\\n  selector: '[ngxDrag]',\\n})\\nexport class NgxDragDirective extends BoundaryDirective implements OnInit, OnDestroy {\\n\\n  /**\\n   * Initial size and position of host element\\n   */\\n  private hostElementRectInitial: {\\n    left: number;\\n    top: number;\\n  } | null = null;\\n\\n  /**\\n   * Emits when directive was destroyed\\n   */\\n  private destroy$ = new Subject();\\n\\n  /**\\n   * Emits when observable target was changed\\n   */\\n  private observableTargetChange$ = new Subject();\\n\\n  /**\\n   * Define positioning strategy.\\n   *\\n   * 'free' - position will changing by 'transform: translate3d()' style\\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\\n   *\\n   * 'relative' - position will changing by 'top' and 'left' style\\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\\n   *\\n   * Default is 'free'.\\n   */\\n  @Input() ngxDragPositionStrategy: PositionStrategy = 'free';\\n\\n  /**\\n   * Locks axis for the dragging\\n   */\\n  @Input() ngxDragLockAxis: Axis = null;\\n\\n  /**\\n   * Disable any drag events\\n   */\\n  @Input() ngxDragDisabled = false;\\n\\n  /**\\n   * Constrain for the dragging element.\\n   * Can be as a HTMLElement or CSS selector.\\n   * You can put 'window' string to define window object as a constrain.\\n   */\\n  @Input() set ngxDragBoundary(boundary: string | HTMLElement) {\\n    this.boundary = boundary;\\n  }\\n\\n  /**\\n   * Emits changes when element was dragged\\n   */\\n  @Output() ngxDragged = new EventEmitter<NgxDrag>();\\n\\n  constructor(\\n    private readonly elementRef: ElementRef<HTMLElement>,\\n    private readonly renderer: Renderer2,\\n    private readonly dragService: DragService,\\n    @Inject(WINDOW) private readonly window: Window,\\n    @Inject(DOCUMENT) private readonly document: Document,\\n    @Inject(PLATFORM_ID) private readonly platformId: object\\n  ) {\\n    console.log('[DragDirective] constructed', window, document)\\n    super(window, document);\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngOnInit(): void {\\n    if (isPlatformServer(this.platformId)) {\\n      return;\\n    }\\n\\n    this.observe();\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngOnDestroy(): void {\\n    this.destroy$.next(true);\\n    this.destroy$.complete();\\n    this.observableTargetChange$.complete();\\n  }\\n\\n  /**\\n   * Observe the element dragging which will be as handle for dragging\\n   */\\n  observe(target = this.elementRef.nativeElement): void {\\n    this.observableTargetChange$.next(true);\\n\\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n    let eventInitial: PositionBase | null = null;\\n\\n    this.dragService\\n      .fromElement(target)\\n      .pipe(\\n        tap((event) => event.nativeEvent.preventDefault()),\\n        map<MovementBase, Movement>((event) => {\\n          if (\\n            !eventInitial ||\\n            eventInitial.x !== event.initial.x ||\\n            eventInitial.y !== event.initial.y\\n          ) {\\n            eventInitial = event.initial;\\n            hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n            if (!this.hostElementRectInitial) {\\n              this.updateInitialRect();\\n            }\\n          }\\n\\n          const offsetFromHost = {\\n            top: event.initial.y - hostElementRect.top,\\n            left: event.initial.x - hostElementRect.left,\\n            bottom: hostElementRect.bottom - event.initial.y,\\n            right: hostElementRect.right - event.initial.x,\\n          } as Boundary;\\n\\n          return {\\n            ...event,\\n            initiator: target,\\n            offsetFromHost,\\n            initial: event.initial,\\n          };\\n        }),\\n        tap(this.onDrag.bind(this)),\\n        takeUntil(this.destroy$),\\n        takeUntil(this.observableTargetChange$)\\n      )\\n      .subscribe();\\n  }\\n\\n  /**\\n   * Update size and position of host element\\n   */\\n  private updateInitialRect(): void {\\n    if (!this.window) {\\n      return;\\n    }\\n\\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n    this.hostElementRectInitial = {\\n      left: this.window.scrollX + rect.left,\\n      top: this.window.scrollY + rect.top,\\n    };\\n  }\\n\\n  /**\\n   * Starts the calculation of drag event and changes host position\\n   */\\n  private onDrag(event: Movement): void {\\n    if (this.ngxDragDisabled) {\\n      return;\\n    }\\n\\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n    const boundaryRect = this.getBoundary();\\n\\n    let left = event.x - event.offsetFromHost.left;\\n    let top = event.y - event.offsetFromHost.top;\\n\\n    if (boundaryRect) {\\n      left = Math.max(boundaryRect.left, left);\\n      left = Math.min(\\n        boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width,\\n        left\\n      );\\n\\n      top = Math.max(boundaryRect.top, top);\\n      top = Math.min(\\n        boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height,\\n        top\\n      );\\n    }\\n\\n    if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\\n      left = left - this.hostElementRectInitial.left + this.window.scrollX;\\n      top = top - this.hostElementRectInitial.top + this.window.scrollY;\\n\\n      if (this.ngxDragLockAxis === 'y') {\\n        top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\\n      }\\n\\n      if (this.ngxDragLockAxis === 'x') {\\n        left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\\n      }\\n\\n      this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\\n      this.emitDrag(event.nativeEvent);\\n      return;\\n    }\\n\\n    if (this.ngxDragLockAxis === 'x') {\\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\\n      this.emitDrag(event.nativeEvent);\\n      return;\\n    }\\n\\n    if (this.ngxDragLockAxis === 'y') {\\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\\n      this.emitDrag(event.nativeEvent);\\n      return;\\n    }\\n\\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\\n    this.emitDrag(event.nativeEvent);\\n  }\\n\\n  /**\\n   * Updates the host style\\n   */\\n  private updateHostStyle(style: string, value: any): void {\\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\\n  }\\n\\n  /**\\n   * Emits drag event to the {@link ngxDragged}\\n   */\\n  private emitDrag(nativeEvent?: Event): void {\\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n    this.ngxDragged.emit({\\n      nativeEvent,\\n      top: rect.top,\\n      right: rect.right,\\n      bottom: rect.bottom,\\n      left: rect.left,\\n    });\\n  }\\n}\\n\",\"import {\\n  AfterViewInit,\\n  Directive,\\n  ElementRef,\\n  Inject,\\n  OnDestroy,\\n  Optional,\\n  PLATFORM_ID,\\n} from '@angular/core';\\nimport { isPlatformServer } from '@angular/common';\\nimport {NgxDragDirective} from './drag.directive';\\n\\n/**\\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Directive({\\n  selector: '[ngxDragHandle]',\\n})\\nexport class NgxDragHandleDirective implements AfterViewInit, OnDestroy {\\n  constructor(\\n    private readonly elementRef: ElementRef<HTMLElement>,\\n    @Optional() private readonly dragDirective: NgxDragDirective,\\n    @Inject(PLATFORM_ID) private readonly platformId: object\\n  ) {}\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngAfterViewInit(): void {\\n    this.observe();\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngOnDestroy(): void {\\n    this.observe();\\n  }\\n\\n  /**\\n   * Sets host element as observable point for {@link NgxDragDirective}\\n   */\\n  private observe(): void {\\n    if (isPlatformServer(this.platformId) || !this.dragDirective) {\\n      return;\\n    }\\n\\n    this.dragDirective.observe(this.elementRef.nativeElement);\\n  }\\n}\\n\",\"export enum NgxResizeHandleType {\\n  TopLeft = 'top-left',\\n  Top = 'top',\\n  TopRight = 'top-right',\\n  Right = 'right',\\n  BottomRight = 'bottom-right',\\n  Bottom = 'bottom',\\n  BottomLeft = 'bottom-left',\\n  Left = 'left',\\n}\\n\",\"import {\\n  AfterViewInit,\\n  Directive,\\n  ElementRef,\\n  EventEmitter,\\n  HostBinding,\\n  Inject,\\n  Input,\\n  OnDestroy,\\n  Output,\\n  PLATFORM_ID,\\n  Renderer2,\\n} from '@angular/core';\\nimport { fromEvent, Subject, Subscription } from 'rxjs';\\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\\nimport { filter, map, switchMap, takeUntil, tap } from 'rxjs/operators';\\nimport {BoundaryDirective} from '../shared/boundary/boundary.directive';\\nimport {Axis} from '../core/axis';\\nimport {PositionType} from './position-type';\\nimport {NgxResize} from './resize';\\nimport {DragService} from '../core/drag.service';\\nimport {WINDOW} from '../core/window.token';\\nimport {MovementBase} from '../core/movement/movement-base';\\nimport {Movement} from '../core/movement/movement';\\nimport {PositionBase} from '../core/position-base';\\nimport {Boundary} from '../shared/boundary/boundary';\\nimport {Scale} from './scale';\\nimport {NgxResizeHandleType} from './resize-handle-type.enum';\\n\\n/**\\n * The directive that allows to resize HTML element on page\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Directive({\\n  selector: '[ngxResize]',\\n})\\nexport class NgxResizeDirective extends BoundaryDirective implements AfterViewInit, OnDestroy {\\n\\n  /**\\n   * Emits when directive was destroyed\\n   */\\n  private destroy$ = new Subject();\\n\\n  /**\\n   * Emits next every time when behaviour for wheel event was changed\\n   */\\n  private wheelBehaviourChange$ = new Subject();\\n\\n  /**\\n   * Emits next every time when behaviour for touches event was changed\\n   */\\n  private touchBehaviourChange$ = new Subject();\\n\\n  /**\\n   * An array of observers which affect on resizable element\\n   */\\n  private observers: { subscription: Subscription; element: HTMLElement }[] = [];\\n\\n  /**\\n   * A regular expression for keyboard code\\n   */\\n  private wheelInitiatorRegExp: RegExp | null = null;\\n\\n  /**\\n   * Make a resize unavailable by wheel\\n   */\\n  private isWheelDisabled = false;\\n\\n  /**\\n   * Make a resize unavailable by touches\\n   */\\n  private isTouchesDisabled = false;\\n\\n  /**\\n   * Minimal width in px\\n   */\\n  @Input() ngxResizeMinWidth = 0;\\n\\n  /**\\n   * Minimal height in px\\n   */\\n  @Input() ngxResizeMinHeight = 0;\\n\\n  /**\\n   * Aspect ratio the element will use during resize\\n   *\\n   * @example\\n   * 16/9 - 9/16 * 100 = 56.25\\n   * 1/1 - 1/1 * 100 = 100\\n   */\\n  @Input() ngxResizeAspectRatio = 0;\\n\\n  /**\\n   * Disables any resize events\\n   */\\n  @Input() ngxResizeDisabled = false;\\n\\n  /**\\n   * Locks axis for the resize\\n   */\\n  @Input() ngxResizeLockAxis: Axis = null;\\n\\n  /**\\n   * Constrain of the resizing area.\\n   * Can be as a HTMLElement or CSS selector.\\n   * You can put 'window' string to define window object as a constrain.\\n   */\\n  @Input() set ngxResizeBoundary(boundary: string | HTMLElement) {\\n    this.boundary = boundary;\\n  }\\n\\n  /**\\n   * A regular expression that matches with keyboard key code.\\n   * When value is provided the element can be scaled by 'Key + wheel'.\\n   * If value not provided the element can be scaled just by 'wheel'.\\n   *\\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\\n   */\\n  @Input() set ngxResizeWheelInitiatorRegExp(pattern: RegExp | string) {\\n    if (!pattern) {\\n      this.wheelInitiatorRegExp = null;\\n      this.subscribeForWheelEvent();\\n      return;\\n    }\\n\\n    this.wheelInitiatorRegExp = new RegExp(pattern);\\n    this.subscribeForWheelEvent();\\n  }\\n\\n  /**\\n   * Disables resize by wheel.\\n   * By default is 'false'.\\n   */\\n  @Input() set ngxResizeWheelDisabled(disabled: boolean) {\\n    this.isWheelDisabled = disabled;\\n    this.subscribeForWheelEvent();\\n  }\\n\\n  /**\\n   * Enables inversion for wheel event\\n   */\\n  @Input() ngxResizeWheelInverse = false;\\n\\n  /**\\n   * Disables resize by touches.\\n   * By default is 'false'.\\n   * Resize work by using two fingers.\\n   */\\n  @Input() set ngxResizeTouchesDisabled(disabled: boolean) {\\n    this.isTouchesDisabled = disabled;\\n    this.subscribeForTouchEvents();\\n  }\\n\\n  /**\\n   * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\\n   * Will be applied to host element.\\n   *\\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\\n   */\\n  @HostBinding('style.position')\\n  @Input()\\n  ngxResizePosition: PositionType = 'absolute';\\n\\n  /**\\n   * Emits changes when element was resized\\n   */\\n  @Output() ngxResized = new EventEmitter<NgxResize>();\\n\\n  constructor(\\n    readonly elementRef: ElementRef<HTMLElement>,\\n    private readonly renderer: Renderer2,\\n    private readonly dragService: DragService,\\n    @Inject(DOCUMENT) private readonly document: Document,\\n    @Inject(WINDOW) private readonly window: Window,\\n    @Inject(PLATFORM_ID) private readonly platformId: object\\n  ) {\\n    super(window, document);\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngAfterViewInit(): void {\\n    if (isPlatformServer(this.platformId)) {\\n      return;\\n    }\\n\\n    this.initialResize();\\n    this.subscribeForWheelEvent();\\n    this.subscribeForTouchEvents();\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngOnDestroy(): void {\\n    this.destroy$.next(true);\\n    this.destroy$.complete();\\n    this.wheelBehaviourChange$.complete();\\n    this.touchBehaviourChange$.complete();\\n  }\\n\\n  /**\\n   * Unsubscribe from the element dragging and remove it from an array of observable objects\\n   */\\n  unsubscribe(target: HTMLElement): void {\\n    const indexOf = this.observers.findIndex((item) => item.element === target);\\n\\n    if (indexOf < 0) {\\n      return;\\n    }\\n\\n    this.observers[indexOf].subscription.unsubscribe();\\n    this.observers.splice(indexOf, 1);\\n  }\\n\\n  /**\\n   * Observe the element dragging which will be as handle for resize\\n   */\\n  observe(target: HTMLElement): void {\\n    if (!this.resolveInitiatorType(target)) {\\n      return;\\n    }\\n\\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n    let eventInitial: PositionBase | null = null;\\n\\n    const subscription$ = this.dragService\\n      .fromElement(target)\\n      .pipe(\\n        tap((event) => event.nativeEvent.preventDefault()),\\n        tap((event) => event.nativeEvent.stopImmediatePropagation()),\\n        map<MovementBase, Movement>((event) => {\\n          if (\\n            !eventInitial ||\\n            eventInitial.x !== event.initial.x ||\\n            eventInitial.y !== event.initial.y\\n          ) {\\n            eventInitial = event.initial;\\n            hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n          }\\n\\n          const offsetFromHost = {\\n            top: event.initial.y - hostElementRect.top,\\n            left: event.initial.x - hostElementRect.left,\\n            bottom: hostElementRect.bottom - event.initial.y,\\n            right: hostElementRect.right - event.initial.x,\\n          } as Boundary;\\n\\n          return {\\n            ...event,\\n            initiator: target,\\n            offsetFromHost,\\n            initial: event.initial,\\n            nativeEvent: event.nativeEvent,\\n          };\\n        }),\\n        tap(this.onResize.bind(this)),\\n        takeUntil(this.destroy$)\\n      )\\n      .subscribe();\\n\\n    this.observers.push({ subscription: subscription$, element: target });\\n  }\\n\\n  /**\\n   * Starts the subscription for touch events\\n   */\\n  private subscribeForTouchEvents(): void {\\n    this.touchBehaviourChange$.next(true);\\n\\n    if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\\n      return;\\n    }\\n\\n    let prevDistance = 0;\\n\\n    const touchStart$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchstart').pipe(\\n      filter((event) => event.targetTouches.length === 2)\\n    );\\n\\n    const touchEnd$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchend');\\n\\n    const touchMove$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchmove', {\\n      passive: false,\\n    }).pipe(\\n      tap((event) => event.preventDefault()),\\n      filter((event) => event.targetTouches.length === 2 && event.changedTouches.length === 2)\\n    );\\n\\n    touchStart$\\n      .pipe(\\n        tap(\\n          (event) => {\\n            const aTouch = event.targetTouches.item(0);\\n            const bTouch = event.targetTouches.item(1);\\n\\n            if (!aTouch || !bTouch) {\\n              return;\\n            }\\n\\n            prevDistance = this.touchesDistance(aTouch, bTouch);\\n          }),\\n        switchMap(() =>\\n          touchMove$.pipe(\\n            tap((event) => {\\n              const aTouch = event.targetTouches.item(0);\\n              const bTouch = event.targetTouches.item(1);\\n\\n              if (!aTouch || !bTouch) {\\n                return;\\n              }\\n\\n              const distance = this.touchesDistance(aTouch, bTouch);\\n\\n              this.onScale({ delta: distance - prevDistance }, event);\\n\\n              prevDistance = distance;\\n            }),\\n            takeUntil(touchEnd$)\\n          )\\n        ),\\n        takeUntil(this.destroy$),\\n        takeUntil(this.touchBehaviourChange$)\\n      )\\n      .subscribe();\\n  }\\n\\n  /**\\n   * Returns distance between two touches\\n   */\\n  private touchesDistance(a: Touch, b: Touch): number {\\n    return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\\n  }\\n\\n  /**\\n   * Make a subscription for wheel events\\n   */\\n  private subscribeForWheelEvent(): void {\\n    this.wheelBehaviourChange$.next(true);\\n\\n    if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\\n      return;\\n    }\\n\\n    const wheel$ = fromEvent<WheelEvent>(this.elementRef.nativeElement, 'wheel').pipe(\\n      tap((event) => event.preventDefault()),\\n      tap((event) => {\\n        const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\\n        this.onScale({ delta }, event);\\n      }),\\n      takeUntil(this.wheelBehaviourChange$),\\n      takeUntil(this.destroy$)\\n    );\\n\\n    if (!this.wheelInitiatorRegExp) {\\n      wheel$.subscribe();\\n      return;\\n    }\\n\\n    const wheelInitiatorFilter = filter<KeyboardEvent>((event) =>\\n      this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\\n\\n    const wheelInitiatorStart$ = fromEvent<KeyboardEvent>(this.window, 'keydown').pipe(\\n      wheelInitiatorFilter\\n    );\\n\\n    const wheelInitiatorEnd$ = fromEvent<KeyboardEvent>(this.window, 'keyup').pipe(\\n      wheelInitiatorFilter\\n    );\\n\\n    wheelInitiatorStart$\\n      .pipe(\\n        switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))),\\n        takeUntil(this.wheelBehaviourChange$),\\n        takeUntil(this.destroy$)\\n      )\\n      .subscribe();\\n  }\\n\\n  /**\\n   * Runs initial resize for the host element\\n   */\\n  private initialResize(): void {\\n    setTimeout(() => {\\n      this.onScale({ delta: 0 });\\n    });\\n  }\\n\\n  /**\\n   * Starts the calculation of scale event and changes host size\\n   */\\n  private onScale(scale: Scale, nativeEvent?: Event): void {\\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n    const boundaryRect = this.getBoundary();\\n\\n    let maxUpscale = scale.delta;\\n\\n    if (boundaryRect) {\\n      maxUpscale = Math.floor(\\n        Math.min(\\n          hostElementRect.top - boundaryRect.top,\\n          boundaryRect.right - hostElementRect.right,\\n          boundaryRect.bottom - hostElementRect.bottom,\\n          hostElementRect.left - boundaryRect.left\\n        )\\n      );\\n    }\\n\\n    const maxDownscale =\\n      Math.max(\\n        0,\\n        Math.min(\\n          hostElementRect.width - this.ngxResizeMinWidth,\\n          hostElementRect.height - this.ngxResizeMinHeight\\n        )\\n      ) * -1;\\n\\n    const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\\n\\n    let top = hostElementRect.top - delta / 2;\\n    let left = hostElementRect.left - delta / 2;\\n\\n    if (boundaryRect) {\\n      top = Math.max(boundaryRect.top, top);\\n      left = Math.max(boundaryRect.left, left);\\n    }\\n\\n    let height = hostElementRect.height + delta;\\n    let width = hostElementRect.width + delta;\\n\\n    if (boundaryRect) {\\n      height = Math.min(boundaryRect.bottom - top, height);\\n      width = Math.min(boundaryRect.right - left, width);\\n    }\\n\\n    if (this.ngxResizeLockAxis === 'x') {\\n      left = hostElementRect.left;\\n      width = hostElementRect.width;\\n    }\\n\\n    if (this.ngxResizeLockAxis === 'y') {\\n      top = hostElementRect.top;\\n      height = hostElementRect.height;\\n    }\\n\\n    const proportionalSize =\\n      this.ngxResizeLockAxis === 'y'\\n        ? this.fromWidthProportion(width)\\n        : this.fromHeightProportion(height);\\n\\n    if (proportionalSize && this.ngxResizeLockAxis === 'y') {\\n      height = proportionalSize;\\n      top = hostElementRect.top - (height - hostElementRect.height) / 2;\\n    }\\n\\n    if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\\n      width = proportionalSize;\\n      left = hostElementRect.left - (width - hostElementRect.width) / 2;\\n    }\\n\\n    if (\\n      boundaryRect &&\\n      (top <= boundaryRect.top ||\\n        top + height >= boundaryRect.bottom ||\\n        left <= boundaryRect.left ||\\n        left + width >= boundaryRect.right)\\n    ) {\\n      top = hostElementRect.top;\\n      height = hostElementRect.height;\\n      left = hostElementRect.left;\\n      width = hostElementRect.width;\\n    }\\n\\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\\n    this.updateHostStyle('width', `${width}px`);\\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\\n    this.updateHostStyle('height', `${height}px`);\\n    this.emitResize(nativeEvent);\\n  }\\n\\n  /**\\n   * Check whether is resize is available for current initiator type\\n   */\\n  private canResize(initiatorType: NgxResizeHandleType): boolean {\\n    switch (initiatorType) {\\n      case NgxResizeHandleType.TopLeft:\\n      case NgxResizeHandleType.TopRight:\\n      case NgxResizeHandleType.BottomLeft:\\n      case NgxResizeHandleType.BottomRight:\\n        return !this.ngxResizeLockAxis;\\n      case NgxResizeHandleType.Left:\\n      case NgxResizeHandleType.Right:\\n        return this.ngxResizeLockAxis !== 'x';\\n      case NgxResizeHandleType.Top:\\n      case NgxResizeHandleType.Bottom:\\n        return this.ngxResizeLockAxis !== 'y';\\n    }\\n\\n    return !this.ngxResizeLockAxis;\\n  }\\n\\n  /**\\n   * Starts the calculation of resize event and changes host size\\n   */\\n  private onResize(event: Movement): void {\\n    if (this.ngxResizeDisabled) {\\n      return;\\n    }\\n\\n    const initiatorType = this.resolveInitiatorType(event.initiator);\\n\\n    if (!initiatorType || !this.canResize(initiatorType)) {\\n      return;\\n    }\\n\\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n    const boundaryRect = this.getBoundary();\\n\\n    if (!boundaryRect) {\\n      return;\\n    }\\n\\n    switch (initiatorType) {\\n      case NgxResizeHandleType.TopLeft:\\n        return this.topLeftMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.Top:\\n        return this.topMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.TopRight:\\n        return this.topRightMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.Right:\\n        return this.rightMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.BottomRight:\\n        return this.bottomRightMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.Bottom:\\n        return this.bottomMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.BottomLeft:\\n        return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\\n      case NgxResizeHandleType.Left:\\n        return this.leftMovement(event, hostElementRect, boundaryRect);\\n    }\\n  }\\n\\n  private topLeftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    if (this.ngxResizeAspectRatio) {\\n      this.topMovement(event, hostElementRect, boundaryRect);\\n      return;\\n    }\\n\\n    this.topMovement(event, hostElementRect, boundaryRect);\\n    this.leftMovement(event, hostElementRect, boundaryRect);\\n  }\\n\\n  private topRightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    if (this.ngxResizeAspectRatio) {\\n      this.topMovement(event, hostElementRect, boundaryRect);\\n      return;\\n    }\\n\\n    this.topMovement(event, hostElementRect, boundaryRect);\\n    this.rightMovement(event, hostElementRect, boundaryRect);\\n  }\\n\\n  private bottomRightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    if (this.ngxResizeAspectRatio) {\\n      this.bottomMovement(event, hostElementRect, boundaryRect);\\n      return;\\n    }\\n\\n    this.bottomMovement(event, hostElementRect, boundaryRect);\\n    this.rightMovement(event, hostElementRect, boundaryRect);\\n  }\\n\\n  private bottomLeftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    if (this.ngxResizeAspectRatio) {\\n      this.bottomMovement(event, hostElementRect, boundaryRect);\\n      return;\\n    }\\n\\n    this.bottomMovement(event, hostElementRect, boundaryRect);\\n    this.leftMovement(event, hostElementRect, boundaryRect);\\n  }\\n\\n  private topMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    let y = event.y - event.offsetFromHost.top;\\n\\n    if (boundaryRect) {\\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\\n    }\\n\\n    let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\\n    let height = hostElementRect.height - (top - hostElementRect.top);\\n\\n    const initiatorType = this.resolveInitiatorType(event.initiator);\\n\\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\\n\\n    if (widthProportions) {\\n      top = top + (height - this.fromWidthProportion(widthProportions.width));\\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\\n    }\\n\\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\\n    this.updateHostStyle('height', `${height}px`);\\n\\n    if (widthProportions) {\\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\\n      this.updateHostStyle('width', `${widthProportions.width}px`);\\n    }\\n\\n    this.emitResize(event.nativeEvent);\\n  }\\n\\n  private rightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    let x = event.x + event.offsetFromHost.right;\\n\\n    if (boundaryRect) {\\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\\n    }\\n\\n    let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\\n\\n    if (boundaryRect) {\\n      width = Math.min(width, boundaryRect.right - hostElementRect.left);\\n    }\\n\\n    const initiatorType = this.resolveInitiatorType(event.initiator);\\n\\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\\n\\n    if (heightProportions) {\\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\\n    }\\n\\n    this.updateHostStyle('width', `${width}px`);\\n\\n    if (heightProportions) {\\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\\n      this.updateHostStyle('height', `${heightProportions.height}px`);\\n    }\\n\\n    this.emitResize(event.nativeEvent);\\n  }\\n\\n  private bottomMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    let y = event.y + event.offsetFromHost.bottom;\\n\\n    if (boundaryRect) {\\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\\n    }\\n\\n    let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\\n\\n    if (boundaryRect) {\\n      height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\\n    }\\n\\n    const initiatorType = this.resolveInitiatorType(event.initiator);\\n\\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\\n\\n    if (widthProportions) {\\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\\n    }\\n\\n    this.updateHostStyle('height', `${height}px`);\\n\\n    if (widthProportions) {\\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\\n      this.updateHostStyle('width', `${widthProportions.width}px`);\\n    }\\n\\n    this.emitResize(event.nativeEvent);\\n  }\\n\\n  private leftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\\n    let x = event.x - event.offsetFromHost.left;\\n\\n    if (boundaryRect) {\\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\\n    }\\n\\n    let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\\n    let width = hostElementRect.width - (left - hostElementRect.left);\\n\\n    const initiatorType = this.resolveInitiatorType(event.initiator);\\n\\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\\n\\n    if (heightProportions) {\\n      left = left + (width - this.fromHeightProportion(heightProportions.height));\\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\\n    }\\n\\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\\n    this.updateHostStyle('width', `${width}px`);\\n\\n    if (heightProportions) {\\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\\n      this.updateHostStyle('height', `${heightProportions.height}px`);\\n    }\\n\\n    this.emitResize(event.nativeEvent);\\n  }\\n\\n  /**\\n   * Get position and size of width\\n   */\\n  private getWidthProportions(\\n    boundaryRect: Boundary,\\n    hostElementRect: DOMRect,\\n    type: NgxResizeHandleType,\\n    height: number\\n  ): {\\n    left: number;\\n    width: number;\\n  } | null {\\n    let width = this.fromHeightProportion(height);\\n\\n    if (!width) {\\n      return null;\\n    }\\n\\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\\n      width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\\n    }\\n\\n    if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\\n      width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\\n    }\\n\\n    let left = hostElementRect.left;\\n\\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\\n      left = left - (width - hostElementRect.width);\\n    }\\n\\n    if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\\n      left = left - (width - hostElementRect.width) / 2;\\n    }\\n\\n    return { left, width };\\n  }\\n\\n  /**\\n   * Get position and size of height\\n   */\\n  private getHeightProportions(\\n    boundaryRect: Boundary,\\n    hostElementRect: DOMRect,\\n    type: NgxResizeHandleType,\\n    width: number\\n  ): {\\n    top: number;\\n    height: number;\\n  } | null {\\n    let height = this.fromWidthProportion(width);\\n\\n    if (!height) {\\n      return null;\\n    }\\n\\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\\n      height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\\n    }\\n\\n    if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\\n      height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\\n    }\\n\\n    let top = hostElementRect.top;\\n\\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\\n      top = top - (height - hostElementRect.height);\\n    }\\n\\n    if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\\n      top = top - (height - hostElementRect.height) / 2;\\n    }\\n\\n    return { top, height };\\n  }\\n\\n  /**\\n   * Get width based on {@link ngxResizeAspectRatio} from height\\n   */\\n  private fromHeightProportion(height: number): number {\\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor((height / this.ngxResizeAspectRatio) * 100);\\n  }\\n\\n  /**\\n   * Get height based on {@link ngxResizeAspectRatio} from width\\n   */\\n  private fromWidthProportion(width: number): number {\\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor((width * this.ngxResizeAspectRatio) / 100);\\n  }\\n\\n  /**\\n   * Updates host element style\\n   */\\n  private updateHostStyle(style: string, value: any): void {\\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\\n  }\\n\\n  /**\\n   * Resolves the type of handle HTML element\\n   */\\n  private resolveInitiatorType(initiator: HTMLElement): NgxResizeHandleType | null {\\n    return initiator.getAttribute('data-ngx-resize-handle-type') as NgxResizeHandleType;\\n  }\\n\\n  /**\\n   * Emits resize event to the {@link ngxResized}\\n   */\\n  private emitResize(nativeEvent?: Event): void {\\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\\n\\n    this.ngxResized.emit({\\n      nativeEvent,\\n      top: rect.top,\\n      right: rect.right,\\n      bottom: rect.bottom,\\n      left: rect.left,\\n    });\\n  }\\n}\\n\",\"import {\\n  AfterViewInit,\\n  Directive,\\n  ElementRef,\\n  HostBinding,\\n  Inject,\\n  Input,\\n  OnDestroy,\\n  Optional,\\n  PLATFORM_ID,\\n} from '@angular/core';\\nimport { isPlatformServer } from '@angular/common';\\nimport {NgxResizeHandleType} from './resize-handle-type.enum';\\nimport {NgxResizeDirective} from './resize.directive';\\n\\n/**\\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n *\\n * @dynamic\\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\\n */\\n@Directive({\\n  selector: '[ngxResizeHandle]',\\n})\\nexport class NgxResizeHandleDirective implements AfterViewInit, OnDestroy {\\n  /**\\n   * Sets the attribute which define the side the HTML element will affect during drag\\n   */\\n  @Input('ngxResizeHandle')\\n  @HostBinding('attr.data-ngx-resize-handle-type')\\n  type: NgxResizeHandleType | null = null;\\n\\n  constructor(\\n    private readonly elementRef: ElementRef<HTMLElement>,\\n    @Inject(PLATFORM_ID) private readonly platformId: object,\\n    @Optional() private readonly resizeDirective: NgxResizeDirective\\n  ) {}\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngAfterViewInit(): void {\\n    if (isPlatformServer(this.platformId) || !this.resizeDirective) {\\n      return;\\n    }\\n\\n    this.resizeDirective.observe(this.elementRef.nativeElement);\\n  }\\n\\n  /**\\n   * @inheritDoc\\n   */\\n  ngOnDestroy(): void {\\n    if (!this.resizeDirective) {\\n      return;\\n    }\\n\\n    this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\\n  }\\n}\\n\",\"import {NgModule} from '@angular/core';\\nimport {BoundaryDirective} from './boundary/boundary.directive';\\n\\n\\n/**\\n * @internal\\n */\\n@NgModule({\\n  declarations: [\\n    BoundaryDirective\\n  ],\\n  exports: [\\n    BoundaryDirective\\n  ]\\n})\\nexport class SharedModule { }\\n\",\"import {NgModule} from '@angular/core';\\nimport {NgxDragDirective} from './drag/drag.directive';\\nimport {NgxDragHandleDirective} from './drag/drag-handle.directive';\\nimport {NgxResizeDirective} from './resize/resize.directive';\\nimport {NgxResizeHandleDirective} from './resize/resize-handle.directive';\\nimport {SharedModule} from './shared/shared.module';\\n\\n/**\\n * The module provides opportunity to use drag and resize functionality on HTML elements\\n *\\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\\n */\\n@NgModule({\\n  imports: [\\n    SharedModule\\n  ],\\n  declarations: [\\n    NgxDragDirective,\\n    NgxDragHandleDirective,\\n    NgxResizeDirective,\\n    NgxResizeHandleDirective\\n  ],\\n  exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\\n})\\nexport class NgxDragResizeModule { }\\n\",\"/*\\n * Public API Surface of ngx-drag-resize\\n */\\n\\nexport * from './lib/drag-resize.module';\\nexport * from './lib/drag/drag.directive';\\nexport * from './lib/drag/drag-handle.directive';\\nexport * from './lib/resize/resize.directive';\\nexport * from './lib/resize/resize-handle.directive';\\nexport * from './lib/resize/resize-handle-type.enum';\\nexport * from './lib/drag/drag';\\nexport * from './lib/resize/resize';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[\"i1.DragService\",\"i1.NgxResizeDirective\"],\"mappings\":\"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\"}","type":"asset"}]}