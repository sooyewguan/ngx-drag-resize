{"ast":null,"code":"import _defineProperty from \"/Users/sooyewguan/Desktop/ngx-drag-resize/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { Directive, InjectionToken, Injectable, Inject, EventEmitter, PLATFORM_ID, Input, Output, Optional, HostBinding, NgModule } from '@angular/core';\nimport { merge, fromEvent, EMPTY, Subject } from 'rxjs';\nimport { tap, map, switchMap, takeUntil, filter } from 'rxjs/operators';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\n\n/**\n * The directive is used to work with boundary area for HTML element\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass BoundaryDirective {\n  constructor(windowObject, documentObject) {\n    _defineProperty(this, \"windowObject\", void 0);\n    _defineProperty(this, \"documentObject\", void 0);\n    /**\n     * CSS selector or HTML element\n     */\n    _defineProperty(this, \"boundary\", null);\n    this.windowObject = windowObject;\n    this.documentObject = documentObject;\n  }\n  /**\n   * Get boundary position based on {@link boundary}\n   */\n  getBoundary() {\n    const rect = {};\n    const boundaryElement = this.resolveBoundaryElement();\n    if (boundaryElement instanceof Element) {\n      const boundaryElementRect = boundaryElement.getBoundingClientRect();\n      rect.left = boundaryElementRect.left;\n      rect.top = boundaryElementRect.top;\n      rect.bottom = boundaryElementRect.bottom;\n      rect.right = boundaryElementRect.right;\n      return rect;\n    }\n    if (boundaryElement instanceof Window && this.windowObject) {\n      rect.top = 0;\n      rect.left = 0;\n      rect.right = this.windowObject.innerWidth;\n      rect.bottom = this.windowObject.innerHeight;\n      return rect;\n    }\n    return null;\n  }\n  /**\n   * Resolves HTML element based on {@link boundary}\n   */\n  resolveBoundaryElement() {\n    if (!this.boundary) {\n      return null;\n    }\n    if (this.boundary === 'window' && this.windowObject) {\n      return this.windowObject;\n    }\n    if (typeof this.boundary === 'string') {\n      return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\n    }\n    return this.boundary;\n  }\n  /**\n   * Returns positional value based on boundary position\n   */\n  basedOnBoundary(value, position) {\n    const boundary = this.getBoundary();\n    if (!boundary) {\n      return value;\n    }\n    switch (position) {\n      case 'left':\n        return value - boundary.left;\n      case 'top':\n        return value - boundary.top;\n    }\n    return value;\n  }\n}\n_defineProperty(BoundaryDirective, \"\\u0275fac\", function BoundaryDirective_Factory(t) {\n  return new (t || BoundaryDirective)(i0.ɵɵdirectiveInject(Window), i0.ɵɵdirectiveInject(Document));\n});\n_defineProperty(BoundaryDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: BoundaryDirective,\n  selectors: [[\"\", \"ngxBoundary\", \"\"]]\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BoundaryDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxBoundary]'\n    }]\n  }], function () {\n    return [{\n      type: Window\n    }, {\n      type: Document\n    }];\n  }, null);\n})();\n\n/**\n * A DI Token representing the window object.\n *\n * Note: might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\n *\n * @internal\n */\nconst WINDOW = new InjectionToken('lib.window', {\n  factory: () => typeof window !== 'undefined' ? window : null\n});\n\n/**\n * The service that allows to observe the element dragging\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass DragService {\n  constructor(document, window) {\n    _defineProperty(this, \"document\", void 0);\n    _defineProperty(this, \"window\", void 0);\n    /**\n     * Emits on mouse or touch event was ended\n     */\n    _defineProperty(this, \"leave$\", merge(fromEvent(this.document, 'mouseup'), fromEvent(this.document, 'touchend')));\n    /**\n     * Emits on mouse or touch move\n     */\n    _defineProperty(this, \"move$\", merge(fromEvent(this.document, 'mousemove'), fromEvent(this.document, 'touchmove')));\n    this.document = document;\n    this.window = window;\n  }\n  /**\n   * Creates an observable that emits drag event\n   */\n  fromElement(target) {\n    if (!this.document) {\n      return EMPTY;\n    }\n    const enter$ = merge(fromEvent(target, 'mousedown'), fromEvent(target, 'touchstart'));\n    return enter$.pipe(tap(event => event.preventDefault()), map(event => this.fromEnter(event)), switchMap(event => this.forMove(event)));\n  }\n  /**\n   * Returns position of mouse or touch event\n   */\n  fromMovementNativeEvent(event) {\n    let x = 0;\n    let y = 0;\n    if (!this.window) {\n      return {\n        x,\n        y\n      };\n    }\n    if ('TouchEvent' in this.window && event instanceof TouchEvent) {\n      const touch = event.touches.length ? event.touches.item(0) : null;\n      x = touch ? touch.clientX : 0;\n      y = touch ? touch.clientY : 0;\n    }\n    if (event instanceof MouseEvent) {\n      x = event.clientX;\n      y = event.clientY;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  /**\n   * Returns position of event when drag was started\n   */\n  fromEnter(event) {\n    return this.fromMovementNativeEvent(event);\n  }\n  /**\n   * Implements behaviour to detect drag events\n   */\n  forMove(initial) {\n    return this.move$.pipe(map(event => {\n      const positionBase = this.fromMovementNativeEvent(event);\n      return {\n        ...positionBase,\n        initial,\n        nativeEvent: event\n      };\n    }), takeUntil(this.leave$));\n  }\n}\n_defineProperty(DragService, \"\\u0275fac\", function DragService_Factory(t) {\n  return new (t || DragService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(WINDOW));\n});\n_defineProperty(DragService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DragService,\n  factory: DragService.ɵfac,\n  providedIn: 'root'\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DragService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: Window,\n      decorators: [{\n        type: Inject,\n        args: [WINDOW]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * The directive that allows to drag HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragDirective extends BoundaryDirective {\n  /**\n   * Constrain for the dragging element.\n   * Can be as a HTMLElement or CSS selector.\n   * You can put 'window' string to define window object as a constrain.\n   */\n  set ngxDragBoundary(boundary) {\n    this.boundary = boundary;\n  }\n  /**\n   * Emits changes when element was dragged\n   */\n\n  constructor(elementRef, renderer, dragService, window, document, platformId) {\n    console.log('[DragDirective] constructed', window, document);\n    super(window, document);\n    _defineProperty(this, \"elementRef\", void 0);\n    _defineProperty(this, \"renderer\", void 0);\n    _defineProperty(this, \"dragService\", void 0);\n    _defineProperty(this, \"window\", void 0);\n    _defineProperty(this, \"document\", void 0);\n    _defineProperty(this, \"platformId\", void 0);\n    /**\n     * Initial size and position of host element\n     */\n    _defineProperty(this, \"hostElementRectInitial\", null);\n    /**\n     * Emits when directive was destroyed\n     */\n    _defineProperty(this, \"destroy$\", new Subject());\n    /**\n     * Emits when observable target was changed\n     */\n    _defineProperty(this, \"observableTargetChange$\", new Subject());\n    /**\n     * Define positioning strategy.\n     *\n     * 'free' - position will changing by 'transform: translate3d()' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n     *\n     * 'relative' - position will changing by 'top' and 'left' style\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n     *\n     * Default is 'free'.\n     */\n    _defineProperty(this, \"ngxDragPositionStrategy\", 'free');\n    /**\n     * Locks axis for the dragging\n     */\n    _defineProperty(this, \"ngxDragLockAxis\", null);\n    /**\n     * Disable any drag events\n     */\n    _defineProperty(this, \"ngxDragDisabled\", false);\n    _defineProperty(this, \"ngxDragged\", new EventEmitter());\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.dragService = dragService;\n    this.window = window;\n    this.document = document;\n    this.platformId = platformId;\n  }\n  /**\n   * @inheritDoc\n   */\n  ngOnInit() {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n    this.observe();\n  }\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy() {\n    this.destroy$.next(true);\n    this.destroy$.complete();\n    this.observableTargetChange$.complete();\n  }\n  /**\n   * Observe the element dragging which will be as handle for dragging\n   */\n  observe(target = this.elementRef.nativeElement) {\n    this.observableTargetChange$.next(true);\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    let eventInitial = null;\n    this.dragService.fromElement(target).pipe(tap(event => event.nativeEvent.preventDefault()), map(event => {\n      if (!eventInitial || eventInitial.x !== event.initial.x || eventInitial.y !== event.initial.y) {\n        eventInitial = event.initial;\n        hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n        if (!this.hostElementRectInitial) {\n          this.updateInitialRect();\n        }\n      }\n      const offsetFromHost = {\n        top: event.initial.y - hostElementRect.top,\n        left: event.initial.x - hostElementRect.left,\n        bottom: hostElementRect.bottom - event.initial.y,\n        right: hostElementRect.right - event.initial.x\n      };\n      return {\n        ...event,\n        initiator: target,\n        offsetFromHost,\n        initial: event.initial\n      };\n    }), tap(this.onDrag.bind(this)), takeUntil(this.destroy$), takeUntil(this.observableTargetChange$)).subscribe();\n  }\n  /**\n   * Update size and position of host element\n   */\n  updateInitialRect() {\n    if (!this.window) {\n      return;\n    }\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n    this.hostElementRectInitial = {\n      left: this.window.scrollX + rect.left,\n      top: this.window.scrollY + rect.top\n    };\n  }\n  /**\n   * Starts the calculation of drag event and changes host position\n   */\n  onDrag(event) {\n    if (this.ngxDragDisabled) {\n      return;\n    }\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    const boundaryRect = this.getBoundary();\n    let left = event.x - event.offsetFromHost.left;\n    let top = event.y - event.offsetFromHost.top;\n    if (boundaryRect) {\n      left = Math.max(boundaryRect.left, left);\n      left = Math.min(boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width, left);\n      top = Math.max(boundaryRect.top, top);\n      top = Math.min(boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height, top);\n    }\n    if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\n      left = left - this.hostElementRectInitial.left + this.window.scrollX;\n      top = top - this.hostElementRectInitial.top + this.window.scrollY;\n      if (this.ngxDragLockAxis === 'y') {\n        top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\n      }\n      if (this.ngxDragLockAxis === 'x') {\n        left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\n      }\n      this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n    if (this.ngxDragLockAxis === 'x') {\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n    if (this.ngxDragLockAxis === 'y') {\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.emitDrag(event.nativeEvent);\n  }\n  /**\n   * Updates the host style\n   */\n  updateHostStyle(style, value) {\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n  }\n  /**\n   * Emits drag event to the {@link ngxDragged}\n   */\n  emitDrag(nativeEvent) {\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n    this.ngxDragged.emit({\n      nativeEvent,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left\n    });\n  }\n}\n_defineProperty(NgxDragDirective, \"\\u0275fac\", function NgxDragDirective_Factory(t) {\n  return new (t || NgxDragDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(PLATFORM_ID));\n});\n_defineProperty(NgxDragDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: NgxDragDirective,\n  selectors: [[\"\", \"ngxDrag\", \"\"]],\n  inputs: {\n    ngxDragPositionStrategy: \"ngxDragPositionStrategy\",\n    ngxDragLockAxis: \"ngxDragLockAxis\",\n    ngxDragDisabled: \"ngxDragDisabled\",\n    ngxDragBoundary: \"ngxDragBoundary\"\n  },\n  outputs: {\n    ngxDragged: \"ngxDragged\"\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxDrag]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DragService\n    }, {\n      type: Window,\n      decorators: [{\n        type: Inject,\n        args: [WINDOW]\n      }]\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    ngxDragPositionStrategy: [{\n      type: Input\n    }],\n    ngxDragLockAxis: [{\n      type: Input\n    }],\n    ngxDragDisabled: [{\n      type: Input\n    }],\n    ngxDragBoundary: [{\n      type: Input\n    }],\n    ngxDragged: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxDragHandleDirective {\n  constructor(elementRef, dragDirective, platformId) {\n    _defineProperty(this, \"elementRef\", void 0);\n    _defineProperty(this, \"dragDirective\", void 0);\n    _defineProperty(this, \"platformId\", void 0);\n    this.elementRef = elementRef;\n    this.dragDirective = dragDirective;\n    this.platformId = platformId;\n  }\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit() {\n    this.observe();\n  }\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy() {\n    this.observe();\n  }\n  /**\n   * Sets host element as observable point for {@link NgxDragDirective}\n   */\n  observe() {\n    if (isPlatformServer(this.platformId) || !this.dragDirective) {\n      return;\n    }\n    this.dragDirective.observe(this.elementRef.nativeElement);\n  }\n}\n_defineProperty(NgxDragHandleDirective, \"\\u0275fac\", function NgxDragHandleDirective_Factory(t) {\n  return new (t || NgxDragHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NgxDragDirective, 8), i0.ɵɵdirectiveInject(PLATFORM_ID));\n});\n_defineProperty(NgxDragHandleDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: NgxDragHandleDirective,\n  selectors: [[\"\", \"ngxDragHandle\", \"\"]]\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxDragHandle]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: NgxDragDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nvar NgxResizeHandleType;\n(function (NgxResizeHandleType) {\n  NgxResizeHandleType[\"TopLeft\"] = \"top-left\";\n  NgxResizeHandleType[\"Top\"] = \"top\";\n  NgxResizeHandleType[\"TopRight\"] = \"top-right\";\n  NgxResizeHandleType[\"Right\"] = \"right\";\n  NgxResizeHandleType[\"BottomRight\"] = \"bottom-right\";\n  NgxResizeHandleType[\"Bottom\"] = \"bottom\";\n  NgxResizeHandleType[\"BottomLeft\"] = \"bottom-left\";\n  NgxResizeHandleType[\"Left\"] = \"left\";\n})(NgxResizeHandleType || (NgxResizeHandleType = {}));\n\n/**\n * The directive that allows to resize HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeDirective extends BoundaryDirective {\n  /**\n   * Constrain of the resizing area.\n   * Can be as a HTMLElement or CSS selector.\n   * You can put 'window' string to define window object as a constrain.\n   */\n  set ngxResizeBoundary(boundary) {\n    this.boundary = boundary;\n  }\n  /**\n   * A regular expression that matches with keyboard key code.\n   * When value is provided the element can be scaled by 'Key + wheel'.\n   * If value not provided the element can be scaled just by 'wheel'.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n   */\n  set ngxResizeWheelInitiatorRegExp(pattern) {\n    if (!pattern) {\n      this.wheelInitiatorRegExp = null;\n      this.subscribeForWheelEvent();\n      return;\n    }\n    this.wheelInitiatorRegExp = new RegExp(pattern);\n    this.subscribeForWheelEvent();\n  }\n  /**\n   * Disables resize by wheel.\n   * By default is 'false'.\n   */\n  set ngxResizeWheelDisabled(disabled) {\n    this.isWheelDisabled = disabled;\n    this.subscribeForWheelEvent();\n  }\n  /**\n   * Enables inversion for wheel event\n   */\n\n  /**\n   * Disables resize by touches.\n   * By default is 'false'.\n   * Resize work by using two fingers.\n   */\n  set ngxResizeTouchesDisabled(disabled) {\n    this.isTouchesDisabled = disabled;\n    this.subscribeForTouchEvents();\n  }\n  /**\n   * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\n   * Will be applied to host element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n   */\n\n  constructor(elementRef, renderer, dragService, document, window, platformId) {\n    super(window, document);\n    _defineProperty(this, \"elementRef\", void 0);\n    _defineProperty(this, \"renderer\", void 0);\n    _defineProperty(this, \"dragService\", void 0);\n    _defineProperty(this, \"document\", void 0);\n    _defineProperty(this, \"window\", void 0);\n    _defineProperty(this, \"platformId\", void 0);\n    /**\n     * Emits when directive was destroyed\n     */\n    _defineProperty(this, \"destroy$\", new Subject());\n    /**\n     * Emits next every time when behaviour for wheel event was changed\n     */\n    _defineProperty(this, \"wheelBehaviourChange$\", new Subject());\n    /**\n     * Emits next every time when behaviour for touches event was changed\n     */\n    _defineProperty(this, \"touchBehaviourChange$\", new Subject());\n    /**\n     * An array of observers which affect on resizable element\n     */\n    _defineProperty(this, \"observers\", []);\n    /**\n     * A regular expression for keyboard code\n     */\n    _defineProperty(this, \"wheelInitiatorRegExp\", null);\n    /**\n     * Make a resize unavailable by wheel\n     */\n    _defineProperty(this, \"isWheelDisabled\", false);\n    /**\n     * Make a resize unavailable by touches\n     */\n    _defineProperty(this, \"isTouchesDisabled\", false);\n    /**\n     * Minimal width in px\n     */\n    _defineProperty(this, \"ngxResizeMinWidth\", 0);\n    /**\n     * Minimal height in px\n     */\n    _defineProperty(this, \"ngxResizeMinHeight\", 0);\n    /**\n     * Aspect ratio the element will use during resize\n     *\n     * @example\n     * 16/9 - 9/16 * 100 = 56.25\n     * 1/1 - 1/1 * 100 = 100\n     */\n    _defineProperty(this, \"ngxResizeAspectRatio\", 0);\n    /**\n     * Disables any resize events\n     */\n    _defineProperty(this, \"ngxResizeDisabled\", false);\n    /**\n     * Locks axis for the resize\n     */\n    _defineProperty(this, \"ngxResizeLockAxis\", null);\n    _defineProperty(this, \"ngxResizeWheelInverse\", false);\n    _defineProperty(this, \"ngxResizePosition\", 'absolute');\n    /**\n     * Emits changes when element was resized\n     */\n    _defineProperty(this, \"ngxResized\", new EventEmitter());\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.dragService = dragService;\n    this.document = document;\n    this.window = window;\n    this.platformId = platformId;\n  }\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n    this.initialResize();\n    this.subscribeForWheelEvent();\n    this.subscribeForTouchEvents();\n  }\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy() {\n    this.destroy$.next(true);\n    this.destroy$.complete();\n    this.wheelBehaviourChange$.complete();\n    this.touchBehaviourChange$.complete();\n  }\n  /**\n   * Unsubscribe from the element dragging and remove it from an array of observable objects\n   */\n  unsubscribe(target) {\n    const indexOf = this.observers.findIndex(item => item.element === target);\n    if (indexOf < 0) {\n      return;\n    }\n    this.observers[indexOf].subscription.unsubscribe();\n    this.observers.splice(indexOf, 1);\n  }\n  /**\n   * Observe the element dragging which will be as handle for resize\n   */\n  observe(target) {\n    if (!this.resolveInitiatorType(target)) {\n      return;\n    }\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    let eventInitial = null;\n    const subscription$ = this.dragService.fromElement(target).pipe(tap(event => event.nativeEvent.preventDefault()), tap(event => event.nativeEvent.stopImmediatePropagation()), map(event => {\n      if (!eventInitial || eventInitial.x !== event.initial.x || eventInitial.y !== event.initial.y) {\n        eventInitial = event.initial;\n        hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n      }\n      const offsetFromHost = {\n        top: event.initial.y - hostElementRect.top,\n        left: event.initial.x - hostElementRect.left,\n        bottom: hostElementRect.bottom - event.initial.y,\n        right: hostElementRect.right - event.initial.x\n      };\n      return {\n        ...event,\n        initiator: target,\n        offsetFromHost,\n        initial: event.initial,\n        nativeEvent: event.nativeEvent\n      };\n    }), tap(this.onResize.bind(this)), takeUntil(this.destroy$)).subscribe();\n    this.observers.push({\n      subscription: subscription$,\n      element: target\n    });\n  }\n  /**\n   * Starts the subscription for touch events\n   */\n  subscribeForTouchEvents() {\n    this.touchBehaviourChange$.next(true);\n    if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\n      return;\n    }\n    let prevDistance = 0;\n    const touchStart$ = fromEvent(this.elementRef.nativeElement, 'touchstart').pipe(filter(event => event.targetTouches.length === 2));\n    const touchEnd$ = fromEvent(this.elementRef.nativeElement, 'touchend');\n    const touchMove$ = fromEvent(this.elementRef.nativeElement, 'touchmove', {\n      passive: false\n    }).pipe(tap(event => event.preventDefault()), filter(event => event.targetTouches.length === 2 && event.changedTouches.length === 2));\n    touchStart$.pipe(tap(event => {\n      const aTouch = event.targetTouches.item(0);\n      const bTouch = event.targetTouches.item(1);\n      if (!aTouch || !bTouch) {\n        return;\n      }\n      prevDistance = this.touchesDistance(aTouch, bTouch);\n    }), switchMap(() => touchMove$.pipe(tap(event => {\n      const aTouch = event.targetTouches.item(0);\n      const bTouch = event.targetTouches.item(1);\n      if (!aTouch || !bTouch) {\n        return;\n      }\n      const distance = this.touchesDistance(aTouch, bTouch);\n      this.onScale({\n        delta: distance - prevDistance\n      }, event);\n      prevDistance = distance;\n    }), takeUntil(touchEnd$))), takeUntil(this.destroy$), takeUntil(this.touchBehaviourChange$)).subscribe();\n  }\n  /**\n   * Returns distance between two touches\n   */\n  touchesDistance(a, b) {\n    return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\n  }\n  /**\n   * Make a subscription for wheel events\n   */\n  subscribeForWheelEvent() {\n    this.wheelBehaviourChange$.next(true);\n    if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\n      return;\n    }\n    const wheel$ = fromEvent(this.elementRef.nativeElement, 'wheel').pipe(tap(event => event.preventDefault()), tap(event => {\n      const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\n      this.onScale({\n        delta\n      }, event);\n    }), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$));\n    if (!this.wheelInitiatorRegExp) {\n      wheel$.subscribe();\n      return;\n    }\n    const wheelInitiatorFilter = filter(event => this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\n    const wheelInitiatorStart$ = fromEvent(this.window, 'keydown').pipe(wheelInitiatorFilter);\n    const wheelInitiatorEnd$ = fromEvent(this.window, 'keyup').pipe(wheelInitiatorFilter);\n    wheelInitiatorStart$.pipe(switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))), takeUntil(this.wheelBehaviourChange$), takeUntil(this.destroy$)).subscribe();\n  }\n  /**\n   * Runs initial resize for the host element\n   */\n  initialResize() {\n    setTimeout(() => {\n      this.onScale({\n        delta: 0\n      });\n    });\n  }\n  /**\n   * Starts the calculation of scale event and changes host size\n   */\n  onScale(scale, nativeEvent) {\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    const boundaryRect = this.getBoundary();\n    let maxUpscale = scale.delta;\n    if (boundaryRect) {\n      maxUpscale = Math.floor(Math.min(hostElementRect.top - boundaryRect.top, boundaryRect.right - hostElementRect.right, boundaryRect.bottom - hostElementRect.bottom, hostElementRect.left - boundaryRect.left));\n    }\n    const maxDownscale = Math.max(0, Math.min(hostElementRect.width - this.ngxResizeMinWidth, hostElementRect.height - this.ngxResizeMinHeight)) * -1;\n    const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\n    let top = hostElementRect.top - delta / 2;\n    let left = hostElementRect.left - delta / 2;\n    if (boundaryRect) {\n      top = Math.max(boundaryRect.top, top);\n      left = Math.max(boundaryRect.left, left);\n    }\n    let height = hostElementRect.height + delta;\n    let width = hostElementRect.width + delta;\n    if (boundaryRect) {\n      height = Math.min(boundaryRect.bottom - top, height);\n      width = Math.min(boundaryRect.right - left, width);\n    }\n    if (this.ngxResizeLockAxis === 'x') {\n      left = hostElementRect.left;\n      width = hostElementRect.width;\n    }\n    if (this.ngxResizeLockAxis === 'y') {\n      top = hostElementRect.top;\n      height = hostElementRect.height;\n    }\n    const proportionalSize = this.ngxResizeLockAxis === 'y' ? this.fromWidthProportion(width) : this.fromHeightProportion(height);\n    if (proportionalSize && this.ngxResizeLockAxis === 'y') {\n      height = proportionalSize;\n      top = hostElementRect.top - (height - hostElementRect.height) / 2;\n    }\n    if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\n      width = proportionalSize;\n      left = hostElementRect.left - (width - hostElementRect.width) / 2;\n    }\n    if (boundaryRect && (top <= boundaryRect.top || top + height >= boundaryRect.bottom || left <= boundaryRect.left || left + width >= boundaryRect.right)) {\n      top = hostElementRect.top;\n      height = hostElementRect.height;\n      left = hostElementRect.left;\n      width = hostElementRect.width;\n    }\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('width', `${width}px`);\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.updateHostStyle('height', `${height}px`);\n    this.emitResize(nativeEvent);\n  }\n  /**\n   * Check whether is resize is available for current initiator type\n   */\n  canResize(initiatorType) {\n    switch (initiatorType) {\n      case NgxResizeHandleType.TopLeft:\n      case NgxResizeHandleType.TopRight:\n      case NgxResizeHandleType.BottomLeft:\n      case NgxResizeHandleType.BottomRight:\n        return !this.ngxResizeLockAxis;\n      case NgxResizeHandleType.Left:\n      case NgxResizeHandleType.Right:\n        return this.ngxResizeLockAxis !== 'x';\n      case NgxResizeHandleType.Top:\n      case NgxResizeHandleType.Bottom:\n        return this.ngxResizeLockAxis !== 'y';\n    }\n    return !this.ngxResizeLockAxis;\n  }\n  /**\n   * Starts the calculation of resize event and changes host size\n   */\n  onResize(event) {\n    if (this.ngxResizeDisabled) {\n      return;\n    }\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n    if (!initiatorType || !this.canResize(initiatorType)) {\n      return;\n    }\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    const boundaryRect = this.getBoundary();\n    if (!boundaryRect) {\n      return;\n    }\n    switch (initiatorType) {\n      case NgxResizeHandleType.TopLeft:\n        return this.topLeftMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Top:\n        return this.topMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.TopRight:\n        return this.topRightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Right:\n        return this.rightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.BottomRight:\n        return this.bottomRightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Bottom:\n        return this.bottomMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.BottomLeft:\n        return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Left:\n        return this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n  }\n  topLeftMovement(event, hostElementRect, boundaryRect) {\n    if (this.ngxResizeAspectRatio) {\n      this.topMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n    this.topMovement(event, hostElementRect, boundaryRect);\n    this.leftMovement(event, hostElementRect, boundaryRect);\n  }\n  topRightMovement(event, hostElementRect, boundaryRect) {\n    if (this.ngxResizeAspectRatio) {\n      this.topMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n    this.topMovement(event, hostElementRect, boundaryRect);\n    this.rightMovement(event, hostElementRect, boundaryRect);\n  }\n  bottomRightMovement(event, hostElementRect, boundaryRect) {\n    if (this.ngxResizeAspectRatio) {\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n    this.bottomMovement(event, hostElementRect, boundaryRect);\n    this.rightMovement(event, hostElementRect, boundaryRect);\n  }\n  bottomLeftMovement(event, hostElementRect, boundaryRect) {\n    if (this.ngxResizeAspectRatio) {\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n    this.bottomMovement(event, hostElementRect, boundaryRect);\n    this.leftMovement(event, hostElementRect, boundaryRect);\n  }\n  topMovement(event, hostElementRect, boundaryRect) {\n    let y = event.y - event.offsetFromHost.top;\n    if (boundaryRect) {\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n    }\n    let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\n    let height = hostElementRect.height - (top - hostElementRect.top);\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n    if (widthProportions) {\n      top = top + (height - this.fromWidthProportion(widthProportions.width));\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n    }\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.updateHostStyle('height', `${height}px`);\n    if (widthProportions) {\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n      this.updateHostStyle('width', `${widthProportions.width}px`);\n    }\n    this.emitResize(event.nativeEvent);\n  }\n  rightMovement(event, hostElementRect, boundaryRect) {\n    let x = event.x + event.offsetFromHost.right;\n    if (boundaryRect) {\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n    }\n    let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\n    if (boundaryRect) {\n      width = Math.min(width, boundaryRect.right - hostElementRect.left);\n    }\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n    if (heightProportions) {\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n    }\n    this.updateHostStyle('width', `${width}px`);\n    if (heightProportions) {\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n      this.updateHostStyle('height', `${heightProportions.height}px`);\n    }\n    this.emitResize(event.nativeEvent);\n  }\n  bottomMovement(event, hostElementRect, boundaryRect) {\n    let y = event.y + event.offsetFromHost.bottom;\n    if (boundaryRect) {\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n    }\n    let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\n    if (boundaryRect) {\n      height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\n    }\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n    if (widthProportions) {\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n    }\n    this.updateHostStyle('height', `${height}px`);\n    if (widthProportions) {\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n      this.updateHostStyle('width', `${widthProportions.width}px`);\n    }\n    this.emitResize(event.nativeEvent);\n  }\n  leftMovement(event, hostElementRect, boundaryRect) {\n    let x = event.x - event.offsetFromHost.left;\n    if (boundaryRect) {\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n    }\n    let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\n    let width = hostElementRect.width - (left - hostElementRect.left);\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n    if (heightProportions) {\n      left = left + (width - this.fromHeightProportion(heightProportions.height));\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n    }\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('width', `${width}px`);\n    if (heightProportions) {\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n      this.updateHostStyle('height', `${heightProportions.height}px`);\n    }\n    this.emitResize(event.nativeEvent);\n  }\n  /**\n   * Get position and size of width\n   */\n  getWidthProportions(boundaryRect, hostElementRect, type, height) {\n    let width = this.fromHeightProportion(height);\n    if (!width) {\n      return null;\n    }\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\n      width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\n    }\n    if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\n      width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\n    }\n    let left = hostElementRect.left;\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\n      left = left - (width - hostElementRect.width);\n    }\n    if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\n      left = left - (width - hostElementRect.width) / 2;\n    }\n    return {\n      left,\n      width\n    };\n  }\n  /**\n   * Get position and size of height\n   */\n  getHeightProportions(boundaryRect, hostElementRect, type, width) {\n    let height = this.fromWidthProportion(width);\n    if (!height) {\n      return null;\n    }\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\n      height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\n    }\n    if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\n      height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\n    }\n    let top = hostElementRect.top;\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\n      top = top - (height - hostElementRect.height);\n    }\n    if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\n      top = top - (height - hostElementRect.height) / 2;\n    }\n    return {\n      top,\n      height\n    };\n  }\n  /**\n   * Get width based on {@link ngxResizeAspectRatio} from height\n   */\n  fromHeightProportion(height) {\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor(height / this.ngxResizeAspectRatio * 100);\n  }\n  /**\n   * Get height based on {@link ngxResizeAspectRatio} from width\n   */\n  fromWidthProportion(width) {\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor(width * this.ngxResizeAspectRatio / 100);\n  }\n  /**\n   * Updates host element style\n   */\n  updateHostStyle(style, value) {\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n  }\n  /**\n   * Resolves the type of handle HTML element\n   */\n  resolveInitiatorType(initiator) {\n    return initiator.getAttribute('data-ngx-resize-handle-type');\n  }\n  /**\n   * Emits resize event to the {@link ngxResized}\n   */\n  emitResize(nativeEvent) {\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n    this.ngxResized.emit({\n      nativeEvent,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left\n    });\n  }\n}\n_defineProperty(NgxResizeDirective, \"\\u0275fac\", function NgxResizeDirective_Factory(t) {\n  return new (t || NgxResizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DragService), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(WINDOW), i0.ɵɵdirectiveInject(PLATFORM_ID));\n});\n_defineProperty(NgxResizeDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: NgxResizeDirective,\n  selectors: [[\"\", \"ngxResize\", \"\"]],\n  hostVars: 2,\n  hostBindings: function NgxResizeDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵstyleProp(\"position\", ctx.ngxResizePosition);\n    }\n  },\n  inputs: {\n    ngxResizeMinWidth: \"ngxResizeMinWidth\",\n    ngxResizeMinHeight: \"ngxResizeMinHeight\",\n    ngxResizeAspectRatio: \"ngxResizeAspectRatio\",\n    ngxResizeDisabled: \"ngxResizeDisabled\",\n    ngxResizeLockAxis: \"ngxResizeLockAxis\",\n    ngxResizeBoundary: \"ngxResizeBoundary\",\n    ngxResizeWheelInitiatorRegExp: \"ngxResizeWheelInitiatorRegExp\",\n    ngxResizeWheelDisabled: \"ngxResizeWheelDisabled\",\n    ngxResizeWheelInverse: \"ngxResizeWheelInverse\",\n    ngxResizeTouchesDisabled: \"ngxResizeTouchesDisabled\",\n    ngxResizePosition: \"ngxResizePosition\"\n  },\n  outputs: {\n    ngxResized: \"ngxResized\"\n  },\n  features: [i0.ɵɵInheritDefinitionFeature]\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxResize]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: DragService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: Window,\n      decorators: [{\n        type: Inject,\n        args: [WINDOW]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    ngxResizeMinWidth: [{\n      type: Input\n    }],\n    ngxResizeMinHeight: [{\n      type: Input\n    }],\n    ngxResizeAspectRatio: [{\n      type: Input\n    }],\n    ngxResizeDisabled: [{\n      type: Input\n    }],\n    ngxResizeLockAxis: [{\n      type: Input\n    }],\n    ngxResizeBoundary: [{\n      type: Input\n    }],\n    ngxResizeWheelInitiatorRegExp: [{\n      type: Input\n    }],\n    ngxResizeWheelDisabled: [{\n      type: Input\n    }],\n    ngxResizeWheelInverse: [{\n      type: Input\n    }],\n    ngxResizeTouchesDisabled: [{\n      type: Input\n    }],\n    ngxResizePosition: [{\n      type: HostBinding,\n      args: ['style.position']\n    }, {\n      type: Input\n    }],\n    ngxResized: [{\n      type: Output\n    }]\n  });\n})();\n\n/**\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\nclass NgxResizeHandleDirective {\n  constructor(elementRef, platformId, resizeDirective) {\n    _defineProperty(this, \"elementRef\", void 0);\n    _defineProperty(this, \"platformId\", void 0);\n    _defineProperty(this, \"resizeDirective\", void 0);\n    /**\n     * Sets the attribute which define the side the HTML element will affect during drag\n     */\n    _defineProperty(this, \"type\", null);\n    this.elementRef = elementRef;\n    this.platformId = platformId;\n    this.resizeDirective = resizeDirective;\n  }\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId) || !this.resizeDirective) {\n      return;\n    }\n    this.resizeDirective.observe(this.elementRef.nativeElement);\n  }\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy() {\n    if (!this.resizeDirective) {\n      return;\n    }\n    this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\n  }\n}\n_defineProperty(NgxResizeHandleDirective, \"\\u0275fac\", function NgxResizeHandleDirective_Factory(t) {\n  return new (t || NgxResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(PLATFORM_ID), i0.ɵɵdirectiveInject(NgxResizeDirective, 8));\n});\n_defineProperty(NgxResizeHandleDirective, \"\\u0275dir\", /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: NgxResizeHandleDirective,\n  selectors: [[\"\", \"ngxResizeHandle\", \"\"]],\n  hostVars: 1,\n  hostBindings: function NgxResizeHandleDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"data-ngx-resize-handle-type\", ctx.type);\n    }\n  },\n  inputs: {\n    type: [\"ngxResizeHandle\", \"type\"]\n  }\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxResizeHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxResizeHandle]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: NgxResizeDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    type: [{\n      type: Input,\n      args: ['ngxResizeHandle']\n    }, {\n      type: HostBinding,\n      args: ['attr.data-ngx-resize-handle-type']\n    }]\n  });\n})();\n\n/**\n * @internal\n */\nclass SharedModule {}\n_defineProperty(SharedModule, \"\\u0275fac\", function SharedModule_Factory(t) {\n  return new (t || SharedModule)();\n});\n_defineProperty(SharedModule, \"\\u0275mod\", /*@__PURE__*/i0.ɵɵdefineNgModule({\n  type: SharedModule\n}));\n_defineProperty(SharedModule, \"\\u0275inj\", /*@__PURE__*/i0.ɵɵdefineInjector({}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SharedModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [BoundaryDirective],\n      exports: [BoundaryDirective]\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(SharedModule, {\n    declarations: [BoundaryDirective],\n    exports: [BoundaryDirective]\n  });\n})();\n\n/**\n * The module provides opportunity to use drag and resize functionality on HTML elements\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n */\nclass NgxDragResizeModule {}\n_defineProperty(NgxDragResizeModule, \"\\u0275fac\", function NgxDragResizeModule_Factory(t) {\n  return new (t || NgxDragResizeModule)();\n});\n_defineProperty(NgxDragResizeModule, \"\\u0275mod\", /*@__PURE__*/i0.ɵɵdefineNgModule({\n  type: NgxDragResizeModule\n}));\n_defineProperty(NgxDragResizeModule, \"\\u0275inj\", /*@__PURE__*/i0.ɵɵdefineInjector({\n  imports: [SharedModule]\n}));\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxDragResizeModule, [{\n    type: NgModule,\n    args: [{\n      imports: [SharedModule],\n      declarations: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective],\n      exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n    }]\n  }], null, null);\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxDragResizeModule, {\n    declarations: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective],\n    imports: [SharedModule],\n    exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n  });\n})();\n\n/*\n * Public API Surface of ngx-drag-resize\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxDragDirective, NgxDragHandleDirective, NgxDragResizeModule, NgxResizeDirective, NgxResizeHandleDirective, NgxResizeHandleType };","map":{"version":3,"names":["BoundaryDirective","constructor","windowObject","documentObject","_defineProperty","getBoundary","rect","boundaryElement","resolveBoundaryElement","Element","boundaryElementRect","getBoundingClientRect","left","top","bottom","right","Window","innerWidth","innerHeight","boundary","querySelector","basedOnBoundary","value","position","i0","ɵɵdirectiveInject","Document","selectors","Directive","args","selector","WINDOW","InjectionToken","factory","window","DragService","document","merge","fromEvent","fromElement","target","EMPTY","enter$","pipe","tap","event","preventDefault","map","fromEnter","switchMap","forMove","fromMovementNativeEvent","x","y","TouchEvent","touch","touches","length","item","clientX","clientY","MouseEvent","initial","move$","positionBase","nativeEvent","takeUntil","leave$","ɵɵinject","DOCUMENT","ɵfac","providedIn","Injectable","Inject","NgxDragDirective","ngxDragBoundary","elementRef","renderer","dragService","platformId","console","log","Subject","EventEmitter","ngOnInit","isPlatformServer","observe","ngOnDestroy","destroy$","next","complete","observableTargetChange$","nativeElement","hostElementRect","eventInitial","hostElementRectInitial","updateInitialRect","offsetFromHost","initiator","onDrag","bind","subscribe","scrollX","scrollY","ngxDragDisabled","boundaryRect","Math","max","min","width","height","ngxDragPositionStrategy","ngxDragLockAxis","updateHostStyle","emitDrag","style","setStyle","ngxDragged","emit","NgxDragDirective_Factory","t","ElementRef","Renderer2","PLATFORM_ID","inputs","outputs","features","ɵɵInheritDefinitionFeature","Input","Output","NgxDragHandleDirective","dragDirective","ngAfterViewInit","NgxDragHandleDirective_Factory","Optional","NgxResizeHandleType","NgxResizeDirective","ngxResizeBoundary","ngxResizeWheelInitiatorRegExp","pattern","wheelInitiatorRegExp","subscribeForWheelEvent","RegExp","ngxResizeWheelDisabled","disabled","isWheelDisabled","ngxResizeTouchesDisabled","isTouchesDisabled","subscribeForTouchEvents","initialResize","wheelBehaviourChange$","touchBehaviourChange$","unsubscribe","indexOf","observers","findIndex","element","subscription","splice","resolveInitiatorType","subscription$","stopImmediatePropagation","onResize","push","prevDistance","touchStart$","filter","targetTouches","touchEnd$","touchMove$","passive","changedTouches","aTouch","bTouch","touchesDistance","distance","onScale","delta","a","b","sqrt","pow","wheel$","ngxResizeWheelInverse","deltaY","wheelInitiatorFilter","test","code","wheelInitiatorStart$","wheelInitiatorEnd$","setTimeout","scale","maxUpscale","floor","maxDownscale","ngxResizeMinWidth","ngxResizeMinHeight","ngxResizeLockAxis","proportionalSize","fromWidthProportion","fromHeightProportion","emitResize","canResize","initiatorType","TopLeft","TopRight","BottomLeft","BottomRight","Left","Right","Top","Bottom","ngxResizeDisabled","topLeftMovement","topMovement","topRightMovement","rightMovement","bottomRightMovement","bottomMovement","bottomLeftMovement","leftMovement","ngxResizeAspectRatio","widthProportions","getWidthProportions","heightProportions","getHeightProportions","type","getAttribute","ngxResized","NgxResizeDirective_Factory","hostVars","hostBindings","NgxResizeDirective_HostBindings","rf","ctx","ngxResizePosition","HostBinding","NgxResizeHandleDirective","resizeDirective","NgxResizeHandleDirective_Factory","NgxResizeHandleDirective_HostBindings","SharedModule","NgModule","declarations","exports","NgxDragResizeModule","imports","ngJitMode","ɵɵsetNgModuleScope"],"sources":["/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/shared/boundary/boundary.directive.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/core/window.token.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/core/drag.service.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/drag/drag.directive.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/drag/drag-handle.directive.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/resize/resize-handle-type.enum.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/resize/resize.directive.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/resize/resize-handle.directive.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/shared/shared.module.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/lib/drag-resize.module.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/public-api.ts","/Users/sooyewguan/Desktop/ngx-drag-resize/projects/ngx-drag-resize/src/ngx-drag-resize.ts"],"sourcesContent":["import {Directive} from '@angular/core';\nimport {Boundary} from './boundary';\n\n/**\n * The directive is used to work with boundary area for HTML element\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Directive({\n  selector: '[ngxBoundary]',\n})\nexport class BoundaryDirective {\n  /**\n   * CSS selector or HTML element\n   */\n  protected boundary: string | HTMLElement | Window | null = null;\n\n  constructor(private readonly windowObject?: Window, private readonly documentObject?: Document) {}\n\n  /**\n   * Get boundary position based on {@link boundary}\n   */\n  protected getBoundary(): Boundary | null {\n    const rect = {} as Boundary;\n\n    const boundaryElement = this.resolveBoundaryElement();\n\n    if (boundaryElement instanceof Element) {\n      const boundaryElementRect = boundaryElement.getBoundingClientRect();\n\n      rect.left = boundaryElementRect.left;\n      rect.top = boundaryElementRect.top;\n      rect.bottom = boundaryElementRect.bottom;\n      rect.right = boundaryElementRect.right;\n\n      return rect;\n    }\n\n    if (boundaryElement instanceof Window && this.windowObject) {\n      rect.top = 0;\n      rect.left = 0;\n      rect.right = this.windowObject.innerWidth;\n      rect.bottom = this.windowObject.innerHeight;\n\n      return rect;\n    }\n\n    return null;\n  }\n\n  /**\n   * Resolves HTML element based on {@link boundary}\n   */\n  protected resolveBoundaryElement(): Element | Window | null {\n    if (!this.boundary) {\n      return null;\n    }\n\n    if (this.boundary === 'window' && this.windowObject) {\n      return this.windowObject;\n    }\n\n    if (typeof this.boundary === 'string') {\n      return this.documentObject ? this.documentObject.querySelector(this.boundary) : null;\n    }\n\n    return this.boundary;\n  }\n\n  /**\n   * Returns positional value based on boundary position\n   */\n  protected basedOnBoundary(value: number, position: 'left' | 'top'): number {\n    const boundary = this.getBoundary();\n\n    if (!boundary) {\n      return value;\n    }\n\n    switch (position) {\n      case 'left':\n        return value - boundary.left;\n      case 'top':\n        return value - boundary.top;\n    }\n\n    return value;\n  }\n}\n","import {InjectionToken} from '@angular/core';\n\n/**\n * A DI Token representing the window object.\n *\n * Note: might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker or Server).\n *\n * @internal\n */\nexport const WINDOW = new InjectionToken<Window | null>('lib.window', {\n  factory: () => (typeof window !== 'undefined' ? window : null)\n});\n","import {Inject, Injectable} from '@angular/core';\nimport {EMPTY, fromEvent, merge, Observable} from 'rxjs';\nimport {DOCUMENT} from '@angular/common';\nimport {map, switchMap, takeUntil, tap} from 'rxjs/operators';\nimport {MovementNative} from './movement/movement-native';\nimport {PositionBase} from './position-base';\nimport {MovementBase} from './movement/movement-base';\nimport {WINDOW} from './window.token';\n\n/**\n * The service that allows to observe the element dragging\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @internal\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class DragService {\n  /**\n   * Emits on mouse or touch event was ended\n   */\n  private readonly leave$ = merge(\n    fromEvent<MovementNative>(this.document, 'mouseup'),\n    fromEvent<MovementNative>(this.document, 'touchend')\n  );\n\n  /**\n   * Emits on mouse or touch move\n   */\n  private readonly move$ = merge(\n    fromEvent<MovementNative>(this.document, 'mousemove'),\n    fromEvent<MovementNative>(this.document, 'touchmove')\n  );\n\n  constructor(\n    @Inject(DOCUMENT) private readonly document: Document,\n    @Inject(WINDOW) private readonly window: Window\n  ) {}\n\n  /**\n   * Creates an observable that emits drag event\n   */\n  fromElement(target: HTMLElement): Observable<MovementBase> {\n    if (!this.document) {\n      return EMPTY;\n    }\n\n    const enter$ = merge(\n      fromEvent<MovementNative>(target, 'mousedown'),\n      fromEvent<MovementNative>(target, 'touchstart')\n    );\n\n    return enter$.pipe(\n      tap((event) => event.preventDefault()),\n      map((event) => this.fromEnter(event)),\n      switchMap((event) => this.forMove(event))\n    );\n  }\n\n  /**\n   * Returns position of mouse or touch event\n   */\n  private fromMovementNativeEvent(event: MovementNative): PositionBase {\n    let x = 0;\n    let y = 0;\n\n    if (!this.window) {\n      return { x, y };\n    }\n\n    if ('TouchEvent' in this.window && event instanceof TouchEvent) {\n      const touch = event.touches.length ? event.touches.item(0) : null;\n      x = touch ? touch.clientX : 0;\n      y = touch ? touch.clientY : 0;\n    }\n\n    if (event instanceof MouseEvent) {\n      x = event.clientX;\n      y = event.clientY;\n    }\n\n    return { x, y };\n  }\n\n  /**\n   * Returns position of event when drag was started\n   */\n  private fromEnter(event: MovementNative): PositionBase {\n    return this.fromMovementNativeEvent(event);\n  }\n\n  /**\n   * Implements behaviour to detect drag events\n   */\n  private forMove(initial: PositionBase): Observable<MovementBase> {\n    return this.move$.pipe(\n      map((event) => {\n        const positionBase = this.fromMovementNativeEvent(event);\n\n        return {\n          ...positionBase,\n          initial,\n          nativeEvent: event,\n        };\n      }),\n      takeUntil(this.leave$)\n    );\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n} from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { map, takeUntil, tap } from 'rxjs/operators';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\nimport {BoundaryDirective} from '../shared/boundary/boundary.directive';\nimport {PositionStrategy} from './position-strategy';\nimport {Axis} from '../core/axis';\nimport {NgxDrag} from './drag';\nimport {DragService} from '../core/drag.service';\nimport {WINDOW} from '../core/window.token';\nimport {MovementBase} from '../core/movement/movement-base';\nimport {Movement} from '../core/movement/movement';\nimport {Boundary} from '../shared/boundary/boundary';\nimport {PositionBase} from '../core/position-base';\n\n/**\n * The directive that allows to drag HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Directive({\n  selector: '[ngxDrag]',\n})\nexport class NgxDragDirective extends BoundaryDirective implements OnInit, OnDestroy {\n\n  /**\n   * Initial size and position of host element\n   */\n  private hostElementRectInitial: {\n    left: number;\n    top: number;\n  } | null = null;\n\n  /**\n   * Emits when directive was destroyed\n   */\n  private destroy$ = new Subject();\n\n  /**\n   * Emits when observable target was changed\n   */\n  private observableTargetChange$ = new Subject();\n\n  /**\n   * Define positioning strategy.\n   *\n   * 'free' - position will changing by 'transform: translate3d()' style\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d\n   *\n   * 'relative' - position will changing by 'top' and 'left' style\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n   *\n   * Default is 'free'.\n   */\n  @Input() ngxDragPositionStrategy: PositionStrategy = 'free';\n\n  /**\n   * Locks axis for the dragging\n   */\n  @Input() ngxDragLockAxis: Axis = null;\n\n  /**\n   * Disable any drag events\n   */\n  @Input() ngxDragDisabled = false;\n\n  /**\n   * Constrain for the dragging element.\n   * Can be as a HTMLElement or CSS selector.\n   * You can put 'window' string to define window object as a constrain.\n   */\n  @Input() set ngxDragBoundary(boundary: string | HTMLElement) {\n    this.boundary = boundary;\n  }\n\n  /**\n   * Emits changes when element was dragged\n   */\n  @Output() ngxDragged = new EventEmitter<NgxDrag>();\n\n  constructor(\n    private readonly elementRef: ElementRef<HTMLElement>,\n    private readonly renderer: Renderer2,\n    private readonly dragService: DragService,\n    @Inject(WINDOW) private readonly window: Window,\n    @Inject(DOCUMENT) private readonly document: Document,\n    @Inject(PLATFORM_ID) private readonly platformId: object\n  ) {\n    console.log('[DragDirective] constructed', window, document)\n    super(window, document);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngOnInit(): void {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    this.observe();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy(): void {\n    this.destroy$.next(true);\n    this.destroy$.complete();\n    this.observableTargetChange$.complete();\n  }\n\n  /**\n   * Observe the element dragging which will be as handle for dragging\n   */\n  observe(target = this.elementRef.nativeElement): void {\n    this.observableTargetChange$.next(true);\n\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    let eventInitial: PositionBase | null = null;\n\n    this.dragService\n      .fromElement(target)\n      .pipe(\n        tap((event) => event.nativeEvent.preventDefault()),\n        map<MovementBase, Movement>((event) => {\n          if (\n            !eventInitial ||\n            eventInitial.x !== event.initial.x ||\n            eventInitial.y !== event.initial.y\n          ) {\n            eventInitial = event.initial;\n            hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n\n            if (!this.hostElementRectInitial) {\n              this.updateInitialRect();\n            }\n          }\n\n          const offsetFromHost = {\n            top: event.initial.y - hostElementRect.top,\n            left: event.initial.x - hostElementRect.left,\n            bottom: hostElementRect.bottom - event.initial.y,\n            right: hostElementRect.right - event.initial.x,\n          } as Boundary;\n\n          return {\n            ...event,\n            initiator: target,\n            offsetFromHost,\n            initial: event.initial,\n          };\n        }),\n        tap(this.onDrag.bind(this)),\n        takeUntil(this.destroy$),\n        takeUntil(this.observableTargetChange$)\n      )\n      .subscribe();\n  }\n\n  /**\n   * Update size and position of host element\n   */\n  private updateInitialRect(): void {\n    if (!this.window) {\n      return;\n    }\n\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    this.hostElementRectInitial = {\n      left: this.window.scrollX + rect.left,\n      top: this.window.scrollY + rect.top,\n    };\n  }\n\n  /**\n   * Starts the calculation of drag event and changes host position\n   */\n  private onDrag(event: Movement): void {\n    if (this.ngxDragDisabled) {\n      return;\n    }\n\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    const boundaryRect = this.getBoundary();\n\n    let left = event.x - event.offsetFromHost.left;\n    let top = event.y - event.offsetFromHost.top;\n\n    if (boundaryRect) {\n      left = Math.max(boundaryRect.left, left);\n      left = Math.min(\n        boundaryRect.left + (boundaryRect.right - boundaryRect.left) - hostElementRect.width,\n        left\n      );\n\n      top = Math.max(boundaryRect.top, top);\n      top = Math.min(\n        boundaryRect.top + (boundaryRect.bottom - boundaryRect.top) - hostElementRect.height,\n        top\n      );\n    }\n\n    if (this.ngxDragPositionStrategy === 'free' && this.hostElementRectInitial) {\n      left = left - this.hostElementRectInitial.left + this.window.scrollX;\n      top = top - this.hostElementRectInitial.top + this.window.scrollY;\n\n      if (this.ngxDragLockAxis === 'y') {\n        top = hostElementRect.top - this.hostElementRectInitial.top + this.window.scrollY;\n      }\n\n      if (this.ngxDragLockAxis === 'x') {\n        left = hostElementRect.left - this.hostElementRectInitial.left + this.window.scrollX;\n      }\n\n      this.updateHostStyle('transform', `translate3d(${left}px, ${top}px, 0)`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n\n    if (this.ngxDragLockAxis === 'x') {\n      this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n\n    if (this.ngxDragLockAxis === 'y') {\n      this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n      this.emitDrag(event.nativeEvent);\n      return;\n    }\n\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.emitDrag(event.nativeEvent);\n  }\n\n  /**\n   * Updates the host style\n   */\n  private updateHostStyle(style: string, value: any): void {\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n  }\n\n  /**\n   * Emits drag event to the {@link ngxDragged}\n   */\n  private emitDrag(nativeEvent?: Event): void {\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    this.ngxDragged.emit({\n      nativeEvent,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n    });\n  }\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  Inject,\n  OnDestroy,\n  Optional,\n  PLATFORM_ID,\n} from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport {NgxDragDirective} from './drag.directive';\n\n/**\n * The directive that allows to mark HTML element as handle of dragging element for {@link NgxDragDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Directive({\n  selector: '[ngxDragHandle]',\n})\nexport class NgxDragHandleDirective implements AfterViewInit, OnDestroy {\n  constructor(\n    private readonly elementRef: ElementRef<HTMLElement>,\n    @Optional() private readonly dragDirective: NgxDragDirective,\n    @Inject(PLATFORM_ID) private readonly platformId: object\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit(): void {\n    this.observe();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy(): void {\n    this.observe();\n  }\n\n  /**\n   * Sets host element as observable point for {@link NgxDragDirective}\n   */\n  private observe(): void {\n    if (isPlatformServer(this.platformId) || !this.dragDirective) {\n      return;\n    }\n\n    this.dragDirective.observe(this.elementRef.nativeElement);\n  }\n}\n","export enum NgxResizeHandleType {\n  TopLeft = 'top-left',\n  Top = 'top',\n  TopRight = 'top-right',\n  Right = 'right',\n  BottomRight = 'bottom-right',\n  Bottom = 'bottom',\n  BottomLeft = 'bottom-left',\n  Left = 'left',\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  HostBinding,\n  Inject,\n  Input,\n  OnDestroy,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n} from '@angular/core';\nimport { fromEvent, Subject, Subscription } from 'rxjs';\nimport { DOCUMENT, isPlatformServer } from '@angular/common';\nimport { filter, map, switchMap, takeUntil, tap } from 'rxjs/operators';\nimport {BoundaryDirective} from '../shared/boundary/boundary.directive';\nimport {Axis} from '../core/axis';\nimport {PositionType} from './position-type';\nimport {NgxResize} from './resize';\nimport {DragService} from '../core/drag.service';\nimport {WINDOW} from '../core/window.token';\nimport {MovementBase} from '../core/movement/movement-base';\nimport {Movement} from '../core/movement/movement';\nimport {PositionBase} from '../core/position-base';\nimport {Boundary} from '../shared/boundary/boundary';\nimport {Scale} from './scale';\nimport {NgxResizeHandleType} from './resize-handle-type.enum';\n\n/**\n * The directive that allows to resize HTML element on page\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Directive({\n  selector: '[ngxResize]',\n})\nexport class NgxResizeDirective extends BoundaryDirective implements AfterViewInit, OnDestroy {\n\n  /**\n   * Emits when directive was destroyed\n   */\n  private destroy$ = new Subject();\n\n  /**\n   * Emits next every time when behaviour for wheel event was changed\n   */\n  private wheelBehaviourChange$ = new Subject();\n\n  /**\n   * Emits next every time when behaviour for touches event was changed\n   */\n  private touchBehaviourChange$ = new Subject();\n\n  /**\n   * An array of observers which affect on resizable element\n   */\n  private observers: { subscription: Subscription; element: HTMLElement }[] = [];\n\n  /**\n   * A regular expression for keyboard code\n   */\n  private wheelInitiatorRegExp: RegExp | null = null;\n\n  /**\n   * Make a resize unavailable by wheel\n   */\n  private isWheelDisabled = false;\n\n  /**\n   * Make a resize unavailable by touches\n   */\n  private isTouchesDisabled = false;\n\n  /**\n   * Minimal width in px\n   */\n  @Input() ngxResizeMinWidth = 0;\n\n  /**\n   * Minimal height in px\n   */\n  @Input() ngxResizeMinHeight = 0;\n\n  /**\n   * Aspect ratio the element will use during resize\n   *\n   * @example\n   * 16/9 - 9/16 * 100 = 56.25\n   * 1/1 - 1/1 * 100 = 100\n   */\n  @Input() ngxResizeAspectRatio = 0;\n\n  /**\n   * Disables any resize events\n   */\n  @Input() ngxResizeDisabled = false;\n\n  /**\n   * Locks axis for the resize\n   */\n  @Input() ngxResizeLockAxis: Axis = null;\n\n  /**\n   * Constrain of the resizing area.\n   * Can be as a HTMLElement or CSS selector.\n   * You can put 'window' string to define window object as a constrain.\n   */\n  @Input() set ngxResizeBoundary(boundary: string | HTMLElement) {\n    this.boundary = boundary;\n  }\n\n  /**\n   * A regular expression that matches with keyboard key code.\n   * When value is provided the element can be scaled by 'Key + wheel'.\n   * If value not provided the element can be scaled just by 'wheel'.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n   */\n  @Input() set ngxResizeWheelInitiatorRegExp(pattern: RegExp | string) {\n    if (!pattern) {\n      this.wheelInitiatorRegExp = null;\n      this.subscribeForWheelEvent();\n      return;\n    }\n\n    this.wheelInitiatorRegExp = new RegExp(pattern);\n    this.subscribeForWheelEvent();\n  }\n\n  /**\n   * Disables resize by wheel.\n   * By default is 'false'.\n   */\n  @Input() set ngxResizeWheelDisabled(disabled: boolean) {\n    this.isWheelDisabled = disabled;\n    this.subscribeForWheelEvent();\n  }\n\n  /**\n   * Enables inversion for wheel event\n   */\n  @Input() ngxResizeWheelInverse = false;\n\n  /**\n   * Disables resize by touches.\n   * By default is 'false'.\n   * Resize work by using two fingers.\n   */\n  @Input() set ngxResizeTouchesDisabled(disabled: boolean) {\n    this.isTouchesDisabled = disabled;\n    this.subscribeForTouchEvents();\n  }\n\n  /**\n   * Position CSS style. Allows 'absolute' and 'fixed'. Default is 'absolute'.\n   * Will be applied to host element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position\n   */\n  @HostBinding('style.position')\n  @Input()\n  ngxResizePosition: PositionType = 'absolute';\n\n  /**\n   * Emits changes when element was resized\n   */\n  @Output() ngxResized = new EventEmitter<NgxResize>();\n\n  constructor(\n    readonly elementRef: ElementRef<HTMLElement>,\n    private readonly renderer: Renderer2,\n    private readonly dragService: DragService,\n    @Inject(DOCUMENT) private readonly document: Document,\n    @Inject(WINDOW) private readonly window: Window,\n    @Inject(PLATFORM_ID) private readonly platformId: object\n  ) {\n    super(window, document);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit(): void {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    this.initialResize();\n    this.subscribeForWheelEvent();\n    this.subscribeForTouchEvents();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy(): void {\n    this.destroy$.next(true);\n    this.destroy$.complete();\n    this.wheelBehaviourChange$.complete();\n    this.touchBehaviourChange$.complete();\n  }\n\n  /**\n   * Unsubscribe from the element dragging and remove it from an array of observable objects\n   */\n  unsubscribe(target: HTMLElement): void {\n    const indexOf = this.observers.findIndex((item) => item.element === target);\n\n    if (indexOf < 0) {\n      return;\n    }\n\n    this.observers[indexOf].subscription.unsubscribe();\n    this.observers.splice(indexOf, 1);\n  }\n\n  /**\n   * Observe the element dragging which will be as handle for resize\n   */\n  observe(target: HTMLElement): void {\n    if (!this.resolveInitiatorType(target)) {\n      return;\n    }\n\n    let hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n    let eventInitial: PositionBase | null = null;\n\n    const subscription$ = this.dragService\n      .fromElement(target)\n      .pipe(\n        tap((event) => event.nativeEvent.preventDefault()),\n        tap((event) => event.nativeEvent.stopImmediatePropagation()),\n        map<MovementBase, Movement>((event) => {\n          if (\n            !eventInitial ||\n            eventInitial.x !== event.initial.x ||\n            eventInitial.y !== event.initial.y\n          ) {\n            eventInitial = event.initial;\n            hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n          }\n\n          const offsetFromHost = {\n            top: event.initial.y - hostElementRect.top,\n            left: event.initial.x - hostElementRect.left,\n            bottom: hostElementRect.bottom - event.initial.y,\n            right: hostElementRect.right - event.initial.x,\n          } as Boundary;\n\n          return {\n            ...event,\n            initiator: target,\n            offsetFromHost,\n            initial: event.initial,\n            nativeEvent: event.nativeEvent,\n          };\n        }),\n        tap(this.onResize.bind(this)),\n        takeUntil(this.destroy$)\n      )\n      .subscribe();\n\n    this.observers.push({ subscription: subscription$, element: target });\n  }\n\n  /**\n   * Starts the subscription for touch events\n   */\n  private subscribeForTouchEvents(): void {\n    this.touchBehaviourChange$.next(true);\n\n    if (this.isTouchesDisabled || isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    let prevDistance = 0;\n\n    const touchStart$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchstart').pipe(\n      filter((event) => event.targetTouches.length === 2)\n    );\n\n    const touchEnd$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchend');\n\n    const touchMove$ = fromEvent<TouchEvent>(this.elementRef.nativeElement, 'touchmove', {\n      passive: false,\n    }).pipe(\n      tap((event) => event.preventDefault()),\n      filter((event) => event.targetTouches.length === 2 && event.changedTouches.length === 2)\n    );\n\n    touchStart$\n      .pipe(\n        tap(\n          (event) => {\n            const aTouch = event.targetTouches.item(0);\n            const bTouch = event.targetTouches.item(1);\n\n            if (!aTouch || !bTouch) {\n              return;\n            }\n\n            prevDistance = this.touchesDistance(aTouch, bTouch);\n          }),\n        switchMap(() =>\n          touchMove$.pipe(\n            tap((event) => {\n              const aTouch = event.targetTouches.item(0);\n              const bTouch = event.targetTouches.item(1);\n\n              if (!aTouch || !bTouch) {\n                return;\n              }\n\n              const distance = this.touchesDistance(aTouch, bTouch);\n\n              this.onScale({ delta: distance - prevDistance }, event);\n\n              prevDistance = distance;\n            }),\n            takeUntil(touchEnd$)\n          )\n        ),\n        takeUntil(this.destroy$),\n        takeUntil(this.touchBehaviourChange$)\n      )\n      .subscribe();\n  }\n\n  /**\n   * Returns distance between two touches\n   */\n  private touchesDistance(a: Touch, b: Touch): number {\n    return Math.sqrt(Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2));\n  }\n\n  /**\n   * Make a subscription for wheel events\n   */\n  private subscribeForWheelEvent(): void {\n    this.wheelBehaviourChange$.next(true);\n\n    if (this.isWheelDisabled || isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    const wheel$ = fromEvent<WheelEvent>(this.elementRef.nativeElement, 'wheel').pipe(\n      tap((event) => event.preventDefault()),\n      tap((event) => {\n        const delta = this.ngxResizeWheelInverse ? event.deltaY : event.deltaY * -1;\n        this.onScale({ delta }, event);\n      }),\n      takeUntil(this.wheelBehaviourChange$),\n      takeUntil(this.destroy$)\n    );\n\n    if (!this.wheelInitiatorRegExp) {\n      wheel$.subscribe();\n      return;\n    }\n\n    const wheelInitiatorFilter = filter<KeyboardEvent>((event) =>\n      this.wheelInitiatorRegExp ? this.wheelInitiatorRegExp.test(event.code) : true);\n\n    const wheelInitiatorStart$ = fromEvent<KeyboardEvent>(this.window, 'keydown').pipe(\n      wheelInitiatorFilter\n    );\n\n    const wheelInitiatorEnd$ = fromEvent<KeyboardEvent>(this.window, 'keyup').pipe(\n      wheelInitiatorFilter\n    );\n\n    wheelInitiatorStart$\n      .pipe(\n        switchMap(() => wheel$.pipe(takeUntil(wheelInitiatorEnd$))),\n        takeUntil(this.wheelBehaviourChange$),\n        takeUntil(this.destroy$)\n      )\n      .subscribe();\n  }\n\n  /**\n   * Runs initial resize for the host element\n   */\n  private initialResize(): void {\n    setTimeout(() => {\n      this.onScale({ delta: 0 });\n    });\n  }\n\n  /**\n   * Starts the calculation of scale event and changes host size\n   */\n  private onScale(scale: Scale, nativeEvent?: Event): void {\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    const boundaryRect = this.getBoundary();\n\n    let maxUpscale = scale.delta;\n\n    if (boundaryRect) {\n      maxUpscale = Math.floor(\n        Math.min(\n          hostElementRect.top - boundaryRect.top,\n          boundaryRect.right - hostElementRect.right,\n          boundaryRect.bottom - hostElementRect.bottom,\n          hostElementRect.left - boundaryRect.left\n        )\n      );\n    }\n\n    const maxDownscale =\n      Math.max(\n        0,\n        Math.min(\n          hostElementRect.width - this.ngxResizeMinWidth,\n          hostElementRect.height - this.ngxResizeMinHeight\n        )\n      ) * -1;\n\n    const delta = Math.max(maxDownscale, Math.min(maxUpscale, scale.delta));\n\n    let top = hostElementRect.top - delta / 2;\n    let left = hostElementRect.left - delta / 2;\n\n    if (boundaryRect) {\n      top = Math.max(boundaryRect.top, top);\n      left = Math.max(boundaryRect.left, left);\n    }\n\n    let height = hostElementRect.height + delta;\n    let width = hostElementRect.width + delta;\n\n    if (boundaryRect) {\n      height = Math.min(boundaryRect.bottom - top, height);\n      width = Math.min(boundaryRect.right - left, width);\n    }\n\n    if (this.ngxResizeLockAxis === 'x') {\n      left = hostElementRect.left;\n      width = hostElementRect.width;\n    }\n\n    if (this.ngxResizeLockAxis === 'y') {\n      top = hostElementRect.top;\n      height = hostElementRect.height;\n    }\n\n    const proportionalSize =\n      this.ngxResizeLockAxis === 'y'\n        ? this.fromWidthProportion(width)\n        : this.fromHeightProportion(height);\n\n    if (proportionalSize && this.ngxResizeLockAxis === 'y') {\n      height = proportionalSize;\n      top = hostElementRect.top - (height - hostElementRect.height) / 2;\n    }\n\n    if (proportionalSize && this.ngxResizeLockAxis !== 'y') {\n      width = proportionalSize;\n      left = hostElementRect.left - (width - hostElementRect.width) / 2;\n    }\n\n    if (\n      boundaryRect &&\n      (top <= boundaryRect.top ||\n        top + height >= boundaryRect.bottom ||\n        left <= boundaryRect.left ||\n        left + width >= boundaryRect.right)\n    ) {\n      top = hostElementRect.top;\n      height = hostElementRect.height;\n      left = hostElementRect.left;\n      width = hostElementRect.width;\n    }\n\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('width', `${width}px`);\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.updateHostStyle('height', `${height}px`);\n    this.emitResize(nativeEvent);\n  }\n\n  /**\n   * Check whether is resize is available for current initiator type\n   */\n  private canResize(initiatorType: NgxResizeHandleType): boolean {\n    switch (initiatorType) {\n      case NgxResizeHandleType.TopLeft:\n      case NgxResizeHandleType.TopRight:\n      case NgxResizeHandleType.BottomLeft:\n      case NgxResizeHandleType.BottomRight:\n        return !this.ngxResizeLockAxis;\n      case NgxResizeHandleType.Left:\n      case NgxResizeHandleType.Right:\n        return this.ngxResizeLockAxis !== 'x';\n      case NgxResizeHandleType.Top:\n      case NgxResizeHandleType.Bottom:\n        return this.ngxResizeLockAxis !== 'y';\n    }\n\n    return !this.ngxResizeLockAxis;\n  }\n\n  /**\n   * Starts the calculation of resize event and changes host size\n   */\n  private onResize(event: Movement): void {\n    if (this.ngxResizeDisabled) {\n      return;\n    }\n\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n\n    if (!initiatorType || !this.canResize(initiatorType)) {\n      return;\n    }\n\n    const hostElementRect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    const boundaryRect = this.getBoundary();\n\n    if (!boundaryRect) {\n      return;\n    }\n\n    switch (initiatorType) {\n      case NgxResizeHandleType.TopLeft:\n        return this.topLeftMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Top:\n        return this.topMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.TopRight:\n        return this.topRightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Right:\n        return this.rightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.BottomRight:\n        return this.bottomRightMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Bottom:\n        return this.bottomMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.BottomLeft:\n        return this.bottomLeftMovement(event, hostElementRect, boundaryRect);\n      case NgxResizeHandleType.Left:\n        return this.leftMovement(event, hostElementRect, boundaryRect);\n    }\n  }\n\n  private topLeftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    if (this.ngxResizeAspectRatio) {\n      this.topMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n\n    this.topMovement(event, hostElementRect, boundaryRect);\n    this.leftMovement(event, hostElementRect, boundaryRect);\n  }\n\n  private topRightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    if (this.ngxResizeAspectRatio) {\n      this.topMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n\n    this.topMovement(event, hostElementRect, boundaryRect);\n    this.rightMovement(event, hostElementRect, boundaryRect);\n  }\n\n  private bottomRightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    if (this.ngxResizeAspectRatio) {\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n\n    this.bottomMovement(event, hostElementRect, boundaryRect);\n    this.rightMovement(event, hostElementRect, boundaryRect);\n  }\n\n  private bottomLeftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    if (this.ngxResizeAspectRatio) {\n      this.bottomMovement(event, hostElementRect, boundaryRect);\n      return;\n    }\n\n    this.bottomMovement(event, hostElementRect, boundaryRect);\n    this.leftMovement(event, hostElementRect, boundaryRect);\n  }\n\n  private topMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    let y = event.y - event.offsetFromHost.top;\n\n    if (boundaryRect) {\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n    }\n\n    let top = Math.min(y, hostElementRect.bottom - this.ngxResizeMinHeight);\n    let height = hostElementRect.height - (top - hostElementRect.top);\n\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n\n    if (widthProportions) {\n      top = top + (height - this.fromWidthProportion(widthProportions.width));\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n    }\n\n    this.updateHostStyle('top', `${this.basedOnBoundary(top, 'top')}px`);\n    this.updateHostStyle('height', `${height}px`);\n\n    if (widthProportions) {\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n      this.updateHostStyle('width', `${widthProportions.width}px`);\n    }\n\n    this.emitResize(event.nativeEvent);\n  }\n\n  private rightMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    let x = event.x + event.offsetFromHost.right;\n\n    if (boundaryRect) {\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n    }\n\n    let width = Math.max(this.ngxResizeMinWidth, x - hostElementRect.left);\n\n    if (boundaryRect) {\n      width = Math.min(width, boundaryRect.right - hostElementRect.left);\n    }\n\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n\n    if (heightProportions) {\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n    }\n\n    this.updateHostStyle('width', `${width}px`);\n\n    if (heightProportions) {\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n      this.updateHostStyle('height', `${heightProportions.height}px`);\n    }\n\n    this.emitResize(event.nativeEvent);\n  }\n\n  private bottomMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    let y = event.y + event.offsetFromHost.bottom;\n\n    if (boundaryRect) {\n      y = Math.max(boundaryRect.top, Math.min(y, boundaryRect.bottom));\n    }\n\n    let height = Math.max(this.ngxResizeMinHeight, y - hostElementRect.top);\n\n    if (boundaryRect) {\n      height = Math.min(height, boundaryRect.bottom - hostElementRect.top);\n    }\n\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n\n    const widthProportions = initiatorType ? this.getWidthProportions(boundaryRect, hostElementRect, initiatorType, height) : null;\n\n    if (widthProportions) {\n      height = Math.min(height, this.fromWidthProportion(widthProportions.width));\n    }\n\n    this.updateHostStyle('height', `${height}px`);\n\n    if (widthProportions) {\n      this.updateHostStyle('left', `${this.basedOnBoundary(widthProportions.left, 'left')}px`);\n      this.updateHostStyle('width', `${widthProportions.width}px`);\n    }\n\n    this.emitResize(event.nativeEvent);\n  }\n\n  private leftMovement(event: Movement, hostElementRect: DOMRect, boundaryRect: Boundary): void {\n    let x = event.x - event.offsetFromHost.left;\n\n    if (boundaryRect) {\n      x = Math.max(boundaryRect.left, Math.min(x, boundaryRect.right));\n    }\n\n    let left = Math.min(x, hostElementRect.right - this.ngxResizeMinWidth);\n    let width = hostElementRect.width - (left - hostElementRect.left);\n\n    const initiatorType = this.resolveInitiatorType(event.initiator);\n\n    const heightProportions = initiatorType ? this.getHeightProportions(boundaryRect, hostElementRect, initiatorType, width) : null;\n\n    if (heightProportions) {\n      left = left + (width - this.fromHeightProportion(heightProportions.height));\n      width = Math.min(width, this.fromHeightProportion(heightProportions.height));\n    }\n\n    this.updateHostStyle('left', `${this.basedOnBoundary(left, 'left')}px`);\n    this.updateHostStyle('width', `${width}px`);\n\n    if (heightProportions) {\n      this.updateHostStyle('top', `${this.basedOnBoundary(heightProportions.top, 'top')}px`);\n      this.updateHostStyle('height', `${heightProportions.height}px`);\n    }\n\n    this.emitResize(event.nativeEvent);\n  }\n\n  /**\n   * Get position and size of width\n   */\n  private getWidthProportions(\n    boundaryRect: Boundary,\n    hostElementRect: DOMRect,\n    type: NgxResizeHandleType,\n    height: number\n  ): {\n    left: number;\n    width: number;\n  } | null {\n    let width = this.fromHeightProportion(height);\n\n    if (!width) {\n      return null;\n    }\n\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.BottomLeft) {\n      width = boundaryRect ? Math.min(width, boundaryRect.right - hostElementRect.left) : width;\n    }\n\n    if (type !== NgxResizeHandleType.TopRight && type !== NgxResizeHandleType.BottomRight) {\n      width = boundaryRect ? Math.min(width, hostElementRect.right - boundaryRect.left) : width;\n    }\n\n    let left = hostElementRect.left;\n\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.BottomLeft) {\n      left = left - (width - hostElementRect.width);\n    }\n\n    if (type === NgxResizeHandleType.Top || type === NgxResizeHandleType.Bottom) {\n      left = left - (width - hostElementRect.width) / 2;\n    }\n\n    return { left, width };\n  }\n\n  /**\n   * Get position and size of height\n   */\n  private getHeightProportions(\n    boundaryRect: Boundary,\n    hostElementRect: DOMRect,\n    type: NgxResizeHandleType,\n    width: number\n  ): {\n    top: number;\n    height: number;\n  } | null {\n    let height = this.fromWidthProportion(width);\n\n    if (!height) {\n      return null;\n    }\n\n    if (type !== NgxResizeHandleType.TopLeft && type !== NgxResizeHandleType.TopRight) {\n      height = boundaryRect ? Math.min(height, boundaryRect.bottom - hostElementRect.top) : height;\n    }\n\n    if (type !== NgxResizeHandleType.BottomLeft && type !== NgxResizeHandleType.BottomRight) {\n      height = boundaryRect ? Math.min(height, hostElementRect.bottom - boundaryRect.top) : height;\n    }\n\n    let top = hostElementRect.top;\n\n    if (type === NgxResizeHandleType.TopLeft || type === NgxResizeHandleType.TopRight) {\n      top = top - (height - hostElementRect.height);\n    }\n\n    if (type === NgxResizeHandleType.Left || type === NgxResizeHandleType.Right) {\n      top = top - (height - hostElementRect.height) / 2;\n    }\n\n    return { top, height };\n  }\n\n  /**\n   * Get width based on {@link ngxResizeAspectRatio} from height\n   */\n  private fromHeightProportion(height: number): number {\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor((height / this.ngxResizeAspectRatio) * 100);\n  }\n\n  /**\n   * Get height based on {@link ngxResizeAspectRatio} from width\n   */\n  private fromWidthProportion(width: number): number {\n    return !this.ngxResizeAspectRatio ? 0 : Math.floor((width * this.ngxResizeAspectRatio) / 100);\n  }\n\n  /**\n   * Updates host element style\n   */\n  private updateHostStyle(style: string, value: any): void {\n    this.renderer.setStyle(this.elementRef.nativeElement, style, value);\n  }\n\n  /**\n   * Resolves the type of handle HTML element\n   */\n  private resolveInitiatorType(initiator: HTMLElement): NgxResizeHandleType | null {\n    return initiator.getAttribute('data-ngx-resize-handle-type') as NgxResizeHandleType;\n  }\n\n  /**\n   * Emits resize event to the {@link ngxResized}\n   */\n  private emitResize(nativeEvent?: Event): void {\n    const rect = this.elementRef.nativeElement.getBoundingClientRect();\n\n    this.ngxResized.emit({\n      nativeEvent,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n    });\n  }\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  HostBinding,\n  Inject,\n  Input,\n  OnDestroy,\n  Optional,\n  PLATFORM_ID,\n} from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport {NgxResizeHandleType} from './resize-handle-type.enum';\nimport {NgxResizeDirective} from './resize.directive';\n\n/**\n * The directive that allows to mark HTML element as one of handle of resizing element for {@link NgxResizeDirective}\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n *\n * @dynamic\n * @see https://angular.io/guide/angular-compiler-options#strictmetadataemit\n */\n@Directive({\n  selector: '[ngxResizeHandle]',\n})\nexport class NgxResizeHandleDirective implements AfterViewInit, OnDestroy {\n  /**\n   * Sets the attribute which define the side the HTML element will affect during drag\n   */\n  @Input('ngxResizeHandle')\n  @HostBinding('attr.data-ngx-resize-handle-type')\n  type: NgxResizeHandleType | null = null;\n\n  constructor(\n    private readonly elementRef: ElementRef<HTMLElement>,\n    @Inject(PLATFORM_ID) private readonly platformId: object,\n    @Optional() private readonly resizeDirective: NgxResizeDirective\n  ) {}\n\n  /**\n   * @inheritDoc\n   */\n  ngAfterViewInit(): void {\n    if (isPlatformServer(this.platformId) || !this.resizeDirective) {\n      return;\n    }\n\n    this.resizeDirective.observe(this.elementRef.nativeElement);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  ngOnDestroy(): void {\n    if (!this.resizeDirective) {\n      return;\n    }\n\n    this.resizeDirective.unsubscribe(this.elementRef.nativeElement);\n  }\n}\n","import {NgModule} from '@angular/core';\nimport {BoundaryDirective} from './boundary/boundary.directive';\n\n\n/**\n * @internal\n */\n@NgModule({\n  declarations: [\n    BoundaryDirective\n  ],\n  exports: [\n    BoundaryDirective\n  ]\n})\nexport class SharedModule { }\n","import {NgModule} from '@angular/core';\nimport {NgxDragDirective} from './drag/drag.directive';\nimport {NgxDragHandleDirective} from './drag/drag-handle.directive';\nimport {NgxResizeDirective} from './resize/resize.directive';\nimport {NgxResizeHandleDirective} from './resize/resize-handle.directive';\nimport {SharedModule} from './shared/shared.module';\n\n/**\n * The module provides opportunity to use drag and resize functionality on HTML elements\n *\n * @author Dmytro Parfenov <dmitryparfenov937@gmail.com>\n */\n@NgModule({\n  imports: [\n    SharedModule\n  ],\n  declarations: [\n    NgxDragDirective,\n    NgxDragHandleDirective,\n    NgxResizeDirective,\n    NgxResizeHandleDirective\n  ],\n  exports: [NgxDragDirective, NgxDragHandleDirective, NgxResizeDirective, NgxResizeHandleDirective]\n})\nexport class NgxDragResizeModule { }\n","/*\n * Public API Surface of ngx-drag-resize\n */\n\nexport * from './lib/drag-resize.module';\nexport * from './lib/drag/drag.directive';\nexport * from './lib/drag/drag-handle.directive';\nexport * from './lib/resize/resize.directive';\nexport * from './lib/resize/resize-handle.directive';\nexport * from './lib/resize/resize-handle-type.enum';\nexport * from './lib/drag/drag';\nexport * from './lib/resize/resize';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}